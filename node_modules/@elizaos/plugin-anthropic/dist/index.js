// src/index.ts
import { anthropic } from "@ai-sdk/anthropic";
import { ModelType, logger as logger2 } from "@elizaos/core";
import { generateText } from "ai";

// src/utils.ts
import { logger } from "@elizaos/core";
import { jsonrepair } from "jsonrepair";
var ensureReflectionProperties = (obj, isReflection) => {
  if (!isReflection) return obj;
  if (obj !== null && typeof obj === "object") {
    return {
      ...obj,
      thought: "thought" in obj ? obj.thought || "" : "",
      facts: "facts" in obj ? obj.facts || [] : [],
      relationships: "relationships" in obj ? obj.relationships || [] : []
    };
  }
  return obj;
};
var extractAndParseJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (initialError) {
    logger.debug("Initial JSON parse failed, attempting alternative extraction methods");
    try {
      const repaired = jsonrepair(text);
      return JSON.parse(repaired);
    } catch (repairError) {
      logger.debug("JSONRepair failed, proceeding with manual extraction methods");
    }
    const isJsonWithCodeBlocks = text.trim().startsWith("{") && text.trim().endsWith("}") && text.includes("```");
    if (isJsonWithCodeBlocks) {
      try {
        const codeBlockPlaceholders = [];
        let placeholderCounter = 0;
        const textWithPlaceholders = text.replace(
          /```(\w*)\n([\s\S]*?)```/g,
          (match, language, code) => {
            const placeholder = `__CODE_BLOCK_${placeholderCounter++}__`;
            codeBlockPlaceholders.push({
              placeholder,
              content: `\`\`\`${language}
${code}\`\`\``
            });
            return placeholder;
          }
        );
        let parsed;
        try {
          const repaired = jsonrepair(textWithPlaceholders);
          parsed = JSON.parse(repaired);
        } catch (e) {
          parsed = JSON.parse(textWithPlaceholders);
        }
        const restoreCodeBlocks = (obj) => {
          if (typeof obj === "string") {
            let result = obj;
            for (const { placeholder, content } of codeBlockPlaceholders) {
              result = result.replace(placeholder, content);
            }
            return result;
          } else if (Array.isArray(obj)) {
            return obj.map((item) => restoreCodeBlocks(item));
          } else if (obj !== null && typeof obj === "object") {
            const result = {};
            for (const [key, value] of Object.entries(obj)) {
              result[key] = restoreCodeBlocks(value);
            }
            return result;
          }
          return obj;
        };
        return restoreCodeBlocks(parsed);
      } catch (codeBlockError) {
        logger.debug("Code block preservation failed, continuing with other methods");
      }
    }
    const extractFromCodeBlocks = (text2) => {
      const jsonBlockRegex = /```json\s*([\s\S]*?)\s*```/;
      const jsonMatch = text2.match(jsonBlockRegex);
      if (jsonMatch && jsonMatch[1]) {
        return jsonMatch[1].trim();
      }
      const anyBlockRegex = /```(?:\w*)\s*([\s\S]*?)\s*```/g;
      let match;
      while ((match = anyBlockRegex.exec(text2)) !== null) {
        const blockContent = match[1].trim();
        if (blockContent.startsWith("{") && blockContent.endsWith("}")) {
          return blockContent;
        }
      }
      return null;
    };
    const extractedFromCodeBlock = extractFromCodeBlocks(text);
    if (extractedFromCodeBlock) {
      try {
        return JSON.parse(extractedFromCodeBlock);
      } catch (blockParseError) {
        try {
          const repaired = jsonrepair(extractedFromCodeBlock);
          return JSON.parse(repaired);
        } catch (blockRepairError) {
          logger.debug("Failed to parse JSON from code block after repair");
        }
      }
    }
    const extractJSON = (text2) => {
      const jsonContentRegex = /(^|\n)\s*(\{[\s\S]*\})\s*($|\n)/;
      const contentMatch = text2.match(jsonContentRegex);
      if (contentMatch && contentMatch[2]) {
        return contentMatch[2].trim();
      }
      const jsonPattern = /\{[\s\S]*?\}/g;
      const jsonMatches = text2.match(jsonPattern);
      if (jsonMatches && jsonMatches.length > 0) {
        return [...jsonMatches].sort((a, b) => b.length - a.length)[0];
      }
      return null;
    };
    const extractedJSON = extractJSON(text);
    if (extractedJSON) {
      try {
        return JSON.parse(extractedJSON);
      } catch (extractParseError) {
        try {
          const repaired = jsonrepair(extractedJSON);
          return JSON.parse(repaired);
        } catch (extractRepairError) {
          logger.debug("Failed to parse JSON after extraction and repair");
        }
      }
    }
    const manuallyExtractStructure = (text2) => {
      const thoughtPattern = /"thought"\s*:\s*"([^"]*?)(?:"|$)/;
      const messagePattern = /"message"\s*:\s*"([^"]*?)(?:"|$)/;
      const thoughtMatch = text2.match(thoughtPattern);
      const messageMatch = text2.match(messagePattern);
      if (thoughtMatch || messageMatch) {
        const extractedContent = {
          type: "reconstructed_response"
        };
        if (thoughtMatch) {
          extractedContent.thought = thoughtMatch[1].replace(/\\n/g, "\n");
        }
        if (messageMatch) {
          extractedContent.message = messageMatch[1].replace(/\\n/g, "\n");
        } else {
          let remainingContent = text2;
          if (thoughtMatch) {
            remainingContent = remainingContent.replace(thoughtPattern, "");
          }
          const codeBlocks = [];
          const codeBlockRegex = /```([\w]*)\n([\s\S]*?)```/g;
          let match;
          while ((match = codeBlockRegex.exec(remainingContent)) !== null) {
            codeBlocks.push({
              language: match[1] || "text",
              code: match[2].trim()
            });
          }
          if (codeBlocks.length > 0) {
            extractedContent.codeBlocks = codeBlocks;
            remainingContent = remainingContent.replace(codeBlockRegex, "");
          }
          extractedContent.message = remainingContent.trim();
        }
        return extractedContent;
      }
      if (text2.includes("thought") || text2.includes("facts") || text2.includes("relationships")) {
        logger.debug("Attempting to extract reflection schema components");
        const result = {
          thought: "",
          facts: [],
          relationships: [],
          rawContent: text2
        };
        const thoughtMatch2 = text2.match(/thought["\s:]+([^"{}[\],]+)/i);
        if (thoughtMatch2) {
          result.thought = thoughtMatch2[1].trim();
        }
        return result;
      }
      return null;
    };
    const manuallyExtracted = manuallyExtractStructure(text);
    if (manuallyExtracted) {
      return manuallyExtracted;
    }
    logger.debug(
      "All JSON extraction methods failed, returning structured object with raw content"
    );
    return {
      type: "unstructured_response",
      content: text
    };
  }
};

// src/index.ts
function getSetting(runtime, key, defaultValue) {
  return runtime.getSetting(key) ?? process.env[key] ?? defaultValue;
}
function getApiKey(runtime) {
  return getSetting(runtime, "ANTHROPIC_API_KEY");
}
function getExperimentalTelemetry(runtime) {
  const setting = getSetting(runtime, "ANTHROPIC_EXPERIMENTAL_TELEMETRY", "false");
  const normalizedSetting = String(setting).toLowerCase();
  const result = normalizedSetting === "true";
  return result;
}
function ensureAnthropicAPIKeyExists(runtime) {
  const apiKey = getApiKey(runtime);
  if (!apiKey) {
    throw new Error(
      "ANTHROPIC_API_KEY is missing. Please set it in your environment or runtime settings."
    );
  }
}
var anthropicPlugin = {
  name: "anthropic",
  description: "Anthropic plugin (supports text generation only)",
  config: {
    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
    ANTHROPIC_SMALL_MODEL: process.env.ANTHROPIC_SMALL_MODEL,
    ANTHROPIC_LARGE_MODEL: process.env.ANTHROPIC_LARGE_MODEL,
    ANTHROPIC_EXPERIMENTAL_TELEMETRY: process.env.ANTHROPIC_EXPERIMENTAL_TELEMETRY
  },
  async init(config, runtime) {
    try {
      const apiKey = getApiKey(runtime);
      if (!apiKey) {
        logger2.warn(
          "ANTHROPIC_API_KEY is not set in environment - Anthropic functionality will be limited"
        );
        return;
      }
    } catch (error) {
      logger2.warn(
        `Anthropic plugin configuration issue: ${error} - You need to configure the ANTHROPIC_API_KEY in your environment variables`
      );
    }
  },
  models: {
    [ModelType.TEXT_SMALL]: async (runtime, { prompt, stopSequences = [] }) => {
      ensureAnthropicAPIKeyExists(runtime);
      const temperature = 0.7;
      const smallModel = runtime.getSetting("ANTHROPIC_SMALL_MODEL") ?? "claude-3-haiku-20240307";
      const maxTokens = smallModel.includes("-3-") ? 4096 : 8192;
      const experimentalTelemetry = getExperimentalTelemetry(runtime);
      logger2.log(`[Anthropic] Using TEXT_SMALL model: ${smallModel}`);
      const { text } = await generateText({
        model: anthropic(smallModel),
        prompt,
        // Pass along any system prompt if available.
        system: runtime.character.system ?? void 0,
        temperature,
        maxTokens,
        stopSequences,
        experimental_telemetry: { isEnabled: experimentalTelemetry }
      });
      return text;
    },
    // TEXT_LARGE generation using Anthropics (e.g. using a "claude-3" model).
    [ModelType.TEXT_LARGE]: async (runtime, {
      prompt,
      maxTokens = 8192,
      stopSequences = [],
      temperature = 0.7,
      frequencyPenalty = 0.7,
      presencePenalty = 0.7
    }) => {
      ensureAnthropicAPIKeyExists(runtime);
      const largeModel = runtime.getSetting("ANTHROPIC_LARGE_MODEL") ?? "claude-3-5-sonnet-latest";
      const experimentalTelemetry = getExperimentalTelemetry(runtime);
      logger2.log(`[Anthropic] Using TEXT_LARGE model: ${largeModel}`);
      const { text } = await generateText({
        model: anthropic(largeModel),
        prompt,
        system: runtime.character.system ?? void 0,
        temperature,
        maxTokens,
        stopSequences,
        frequencyPenalty,
        presencePenalty,
        experimental_telemetry: { isEnabled: experimentalTelemetry }
      });
      return text;
    },
    [ModelType.OBJECT_SMALL]: async (runtime, params) => {
      ensureAnthropicAPIKeyExists(runtime);
      const smallModel = runtime.getSetting("ANTHROPIC_SMALL_MODEL") ?? "claude-3-haiku-20240307";
      try {
        const isReflection = params.schema?.facts && params.schema.relationships;
        let jsonPrompt = params.prompt;
        if (!jsonPrompt.includes("```json") && !jsonPrompt.includes("respond with valid JSON")) {
          jsonPrompt += "\nPlease respond with valid JSON only, without any explanations, markdown formatting, or additional text.";
        }
        let systemPrompt = runtime.character.system ? `${runtime.character.system}
You must respond with valid JSON only.` : "You must respond with valid JSON only.";
        if (isReflection) {
          systemPrompt += " Ensure your response includes 'thought', 'facts', and 'relationships' properties exactly as specified in the prompt.";
        } else {
          systemPrompt += " No markdown, no code blocks, no explanation text.";
        }
        const { text } = await generateText({
          model: anthropic(smallModel),
          prompt: jsonPrompt,
          system: systemPrompt,
          temperature: params.temperature || 0.2
          // Lower temperature for more predictable structured output
        });
        try {
          logger2.debug("Attempting to parse response from Anthropic model");
          const jsonObject = extractAndParseJSON(text);
          const processedObject = ensureReflectionProperties(jsonObject, isReflection);
          return processedObject;
        } catch (parseError) {
          logger2.error("Failed to parse JSON from Anthropic response:", parseError);
          logger2.error("Raw response:", text);
          throw new Error("Invalid JSON returned from Anthropic model");
        }
      } catch (error) {
        logger2.error("Error generating object:", error);
        throw error;
      }
    },
    [ModelType.OBJECT_LARGE]: async (runtime, params) => {
      ensureAnthropicAPIKeyExists(runtime);
      const largeModel = runtime.getSetting("ANTHROPIC_LARGE_MODEL") ?? "claude-3-5-sonnet-latest";
      try {
        const isReflection = params.schema?.facts && params.schema.relationships;
        let jsonPrompt = params.prompt;
        if (!jsonPrompt.includes("```json") && !jsonPrompt.includes("respond with valid JSON")) {
          jsonPrompt += "\nPlease respond with valid JSON only, without any explanations, markdown formatting, or additional text.";
        }
        let systemPrompt = runtime.character.system ? `${runtime.character.system}
You must respond with valid JSON only.` : "You must respond with valid JSON only.";
        if (isReflection) {
          systemPrompt += " Ensure your response includes 'thought', 'facts', and 'relationships' properties exactly as specified in the prompt.";
        } else {
          systemPrompt += " No markdown, no code blocks, no explanation text.";
        }
        const { text } = await generateText({
          model: anthropic(largeModel),
          prompt: jsonPrompt,
          system: systemPrompt,
          temperature: params.temperature || 0.2
          // Lower temperature for more predictable structured output
        });
        try {
          logger2.debug("Attempting to parse response from Anthropic model");
          const jsonObject = extractAndParseJSON(text);
          const processedObject = ensureReflectionProperties(jsonObject, isReflection);
          return processedObject;
        } catch (parseError) {
          logger2.error("Failed to parse JSON from Anthropic response:", parseError);
          logger2.error("Raw response:", text);
          throw new Error("Invalid JSON returned from Anthropic model");
        }
      } catch (error) {
        logger2.error("Error generating object:", error);
        throw error;
      }
    }
  },
  tests: [
    {
      name: "anthropic_plugin_tests",
      tests: [
        {
          name: "anthropic_test_text_small",
          fn: async (runtime) => {
            try {
              const text = await runtime.useModel(ModelType.TEXT_SMALL, {
                prompt: "What is the nature of reality in 10 words?"
              });
              if (text.length === 0) {
                throw new Error("Failed to generate text");
              }
              logger2.log("generated with test_text_small:", text);
            } catch (error) {
              logger2.error("Error in test_text_small:", error);
              throw error;
            }
          }
        },
        {
          name: "anthropic_test_text_large",
          fn: async (runtime) => {
            try {
              const text = await runtime.useModel(ModelType.TEXT_LARGE, {
                prompt: "What is the nature of reality in 10 words?"
              });
              if (text.length === 0) {
                throw new Error("Failed to generate text");
              }
              logger2.log("generated with test_text_large:", text);
            } catch (error) {
              logger2.error("Error in test_text_large:", error);
              throw error;
            }
          }
        },
        {
          name: "anthropic_test_object_with_code_blocks",
          fn: async (runtime) => {
            try {
              const result = await runtime.useModel(ModelType.OBJECT_SMALL, {
                prompt: "Give me instructions to install Node.js",
                schema: { type: "object" }
              });
              logger2.log("Generated object with code blocks:", result);
              if (!result || result.error) {
                throw new Error("Failed to generate object with code blocks");
              }
            } catch (error) {
              logger2.error("Error in test_object_with_code_blocks:", error);
              throw error;
            }
          }
        }
      ]
    }
  ]
};
var index_default = anthropicPlugin;
export {
  anthropicPlugin,
  index_default as default
};
//# sourceMappingURL=index.js.map