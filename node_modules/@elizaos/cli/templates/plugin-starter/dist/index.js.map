{"version":3,"sources":["../src/plugin.ts","../src/__tests__/e2e/starter-plugin.ts","../src/index.ts"],"sourcesContent":["import type {\n  Action,\n  ActionResult,\n  Content,\n  GenerateTextParams,\n  HandlerCallback,\n  IAgentRuntime,\n  Memory,\n  Plugin,\n  Provider,\n  ProviderResult,\n  State,\n} from '@elizaos/core';\nimport { ModelType, Service, logger } from '@elizaos/core';\nimport { z } from 'zod';\nimport { StarterPluginTestSuite } from './tests';\n\n/**\n * Defines the configuration schema for a plugin, including the validation rules for the plugin name.\n *\n * @type {import('zod').ZodObject<{ EXAMPLE_PLUGIN_VARIABLE: import('zod').ZodString }>}\n */\nconst configSchema = z.object({\n  EXAMPLE_PLUGIN_VARIABLE: z\n    .string()\n    .min(1, 'Example plugin variable is not provided')\n    .optional()\n    .transform((val) => {\n      if (!val) {\n        logger.warn('Example plugin variable is not provided (this is expected)');\n      }\n      return val;\n    }),\n});\n\n/**\n * Example HelloWorld action\n * This demonstrates the simplest possible action structure\n */\n/**\n * Action representing a hello world message.\n * @typedef {Object} Action\n * @property {string} name - The name of the action.\n * @property {string[]} similes - An array of related actions.\n * @property {string} description - A brief description of the action.\n * @property {Function} validate - Asynchronous function to validate the action.\n * @property {Function} handler - Asynchronous function to handle the action and generate a response.\n * @property {Object[]} examples - An array of example inputs and expected outputs for the action.\n */\nconst helloWorldAction: Action = {\n  name: 'HELLO_WORLD',\n  similes: ['GREET', 'SAY_HELLO'],\n  description: 'Responds with a simple hello world message',\n\n  validate: async (\n    _runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<boolean> => {\n    // Always valid\n    return true;\n  },\n\n  handler: async (\n    _runtime: IAgentRuntime,\n    message: Memory,\n    _state: State | undefined,\n    _options: any,\n    callback?: HandlerCallback,\n    _responses?: Memory[]\n  ): Promise<ActionResult> => {\n    try {\n      logger.info('Handling HELLO_WORLD action');\n\n      // Simple response content for callback\n      const responseContent: Content = {\n        text: 'hello world!',\n        actions: ['HELLO_WORLD'],\n        source: message.content.source,\n      };\n\n      // Call back with the hello world message if callback is provided\n      if (callback) {\n        await callback(responseContent);\n      }\n\n      // Return ActionResult\n      return {\n        text: 'hello world!',\n        success: true,\n        data: {\n          actions: ['HELLO_WORLD'],\n          source: message.content.source,\n        },\n      };\n    } catch (error) {\n      logger.error('Error in HELLO_WORLD action:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error : new Error(String(error)),\n      };\n    }\n  },\n\n  examples: [\n    [\n      {\n        name: '{{name1}}',\n        content: {\n          text: 'Can you say hello?',\n        },\n      },\n      {\n        name: '{{name2}}',\n        content: {\n          text: 'hello world!',\n          actions: ['HELLO_WORLD'],\n        },\n      },\n    ],\n  ],\n};\n\n/**\n * Example Hello World Provider\n * This demonstrates the simplest possible provider implementation\n */\nconst helloWorldProvider: Provider = {\n  name: 'HELLO_WORLD_PROVIDER',\n  description: 'A simple example provider',\n\n  get: async (\n    _runtime: IAgentRuntime,\n    _message: Memory,\n    _state: State | undefined\n  ): Promise<ProviderResult> => {\n    return {\n      text: 'I am a provider',\n      values: {},\n      data: {},\n    };\n  },\n};\n\nexport class StarterService extends Service {\n  static serviceType = 'starter';\n  capabilityDescription =\n    'This is a starter service which is attached to the agent through the starter plugin.';\n  constructor(protected runtime: IAgentRuntime) {\n    super(runtime);\n  }\n\n  static async start(runtime: IAgentRuntime) {\n    logger.info(`*** Starting starter service - MODIFIED: ${new Date().toISOString()} ***`);\n    const service = new StarterService(runtime);\n    return service;\n  }\n\n  static async stop(runtime: IAgentRuntime) {\n    logger.info('*** TESTING DEV MODE - STOP MESSAGE CHANGED! ***');\n    // get the service from the runtime\n    const service = runtime.getService(StarterService.serviceType);\n    if (!service) {\n      throw new Error('Starter service not found');\n    }\n    service.stop();\n  }\n\n  async stop() {\n    logger.info('*** THIRD CHANGE - TESTING FILE WATCHING! ***');\n  }\n}\n\nexport const starterPlugin: Plugin = {\n  name: 'plugin-starter',\n  description: 'Plugin starter for elizaOS',\n  config: {\n    EXAMPLE_PLUGIN_VARIABLE: process.env.EXAMPLE_PLUGIN_VARIABLE,\n  },\n  async init(config: Record<string, string>) {\n    logger.info('*** TESTING DEV MODE - PLUGIN MODIFIED AND RELOADED! ***');\n    try {\n      const validatedConfig = await configSchema.parseAsync(config);\n\n      // Set all environment variables at once\n      for (const [key, value] of Object.entries(validatedConfig)) {\n        if (value) process.env[key] = value;\n      }\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        throw new Error(\n          `Invalid plugin configuration: ${error.errors.map((e) => e.message).join(', ')}`\n        );\n      }\n      throw error;\n    }\n  },\n  models: {\n    [ModelType.TEXT_SMALL]: async (\n      _runtime,\n      { prompt, stopSequences = [] }: GenerateTextParams\n    ) => {\n      return 'Never gonna give you up, never gonna let you down, never gonna run around and desert you...';\n    },\n    [ModelType.TEXT_LARGE]: async (\n      _runtime,\n      {\n        prompt,\n        stopSequences = [],\n        maxTokens = 8192,\n        temperature = 0.7,\n        frequencyPenalty = 0.7,\n        presencePenalty = 0.7,\n      }: GenerateTextParams\n    ) => {\n      return 'Never gonna make you cry, never gonna say goodbye, never gonna tell a lie and hurt you...';\n    },\n  },\n  routes: [\n    {\n      name: 'hello-world-route',\n      path: '/helloworld',\n      type: 'GET',\n      handler: async (_req: any, res: any) => {\n        // send a response\n        res.json({\n          message: 'Hello World!',\n        });\n      },\n    },\n    {\n      name: 'current-time-route',\n      path: '/api/time',\n      type: 'GET',\n      handler: async (_req: any, res: any) => {\n        // Return current time in various formats\n        const now = new Date();\n        res.json({\n          timestamp: now.toISOString(),\n          unix: Math.floor(now.getTime() / 1000),\n          formatted: now.toLocaleString(),\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n        });\n      },\n    },\n  ],\n  events: {\n    MESSAGE_RECEIVED: [\n      async (params) => {\n        logger.debug('MESSAGE_RECEIVED event received');\n        // print the keys\n        logger.debug(Object.keys(params));\n      },\n    ],\n    VOICE_MESSAGE_RECEIVED: [\n      async (params) => {\n        logger.debug('VOICE_MESSAGE_RECEIVED event received');\n        // print the keys\n        logger.debug(Object.keys(params));\n      },\n    ],\n    WORLD_CONNECTED: [\n      async (params) => {\n        logger.debug('WORLD_CONNECTED event received');\n        // print the keys\n        logger.debug(Object.keys(params));\n      },\n    ],\n    WORLD_JOINED: [\n      async (params) => {\n        logger.debug('WORLD_JOINED event received');\n        // print the keys\n        logger.debug(Object.keys(params));\n      },\n    ],\n  },\n  services: [StarterService],\n  actions: [helloWorldAction],\n  providers: [helloWorldProvider],\n  tests: [StarterPluginTestSuite],\n  // dependencies: ['@elizaos/plugin-knowledge'], <--- plugin dependecies go here (if requires another plugin)\n};\n\nexport default starterPlugin;\n","import { type Content, type HandlerCallback } from '@elizaos/core';\n\n/**\n * E2E (End-to-End) Test Suite for ElizaOS Plugins\n * ================================================\n *\n * This file contains end-to-end tests that run within a real ElizaOS runtime environment.\n * Unlike unit tests that test individual components in isolation, e2e tests validate\n * the entire plugin behavior in a production-like environment.\n *\n * NOTE: The tests are properly structured and included in the plugin build.\n * If the test runner is not detecting these tests, it may be looking at the wrong\n * plugin name or there may be a test runner configuration issue. The tests are\n * exported correctly through src/tests.ts and included in the plugin's tests array.\n *\n * HOW E2E TESTS WORK:\n * -------------------\n * 1. Tests are executed by the ElizaOS test runner using `elizaos test e2e`\n * 2. Each test receives a real runtime instance with the plugin loaded\n * 3. Tests can interact with the runtime just like in production\n * 4. Tests throw errors to indicate failure (no assertion library needed)\n *\n * WRITING NEW E2E TESTS:\n * ----------------------\n * 1. Add a new test object to the `tests` array below\n * 2. Each test must have:\n *    - `name`: A unique identifier for the test\n *    - `fn`: An async function that receives the runtime and performs the test\n *\n * Example structure:\n * ```typescript\n * {\n *   name: 'my_new_test',\n *   fn: async (runtime) => {\n *     // Your test logic here\n *     if (someCondition !== expected) {\n *       throw new Error('Test failed: reason');\n *     }\n *   }\n * }\n * ```\n *\n * BEST PRACTICES:\n * ---------------\n * - Test real user scenarios, not implementation details\n * - Use descriptive test names that explain what's being tested\n * - Include clear error messages that help diagnose failures\n * - Test both success and failure paths\n * - Clean up any resources created during tests\n *\n * AVAILABLE RUNTIME METHODS:\n * --------------------------\n * - runtime.getService(type): Get a service instance\n * - runtime.character: Access character configuration\n * - runtime.models: Access AI models\n * - runtime.db: Access database methods\n * - runtime.actions: Access registered actions\n * - runtime.providers: Access registered providers\n *\n * For more details, see the ElizaOS documentation.\n */\n\n// Define a minimal TestSuite interface that matches what's needed\ninterface TestSuite {\n  name: string;\n  description?: string;\n  tests: Array<{\n    name: string;\n    fn: (runtime: any) => Promise<any>;\n  }>;\n}\n\n// Define minimal interfaces for the types we need\ntype UUID = `${string}-${string}-${string}-${string}-${string}`;\n\ninterface Memory {\n  entityId: UUID;\n  roomId: UUID;\n  content: {\n    text: string;\n    source: string;\n    actions?: string[];\n  };\n}\n\ninterface State {\n  values: Record<string, any>;\n  data: Record<string, any>;\n  text: string;\n}\n\nexport const StarterPluginTestSuite: TestSuite = {\n  name: 'plugin_starter_test_suite',\n  description: 'E2E tests for the starter plugin',\n\n  tests: [\n    /**\n     * Basic Plugin Verification Test\n     * ------------------------------\n     * This test verifies that the plugin is properly loaded and initialized\n     * within the runtime environment.\n     */\n    {\n      name: 'example_test',\n      fn: async (runtime) => {\n        // Test the character name\n        if (runtime.character.name !== 'Eliza') {\n          throw new Error(\n            `Expected character name to be \"Eliza\" but got \"${runtime.character.name}\"`\n          );\n        }\n        // Verify the plugin is loaded properly\n        const service = runtime.getService('starter');\n        if (!service) {\n          throw new Error('Starter service not found');\n        }\n      },\n    },\n\n    /**\n     * Action Registration Test\n     * ------------------------\n     * Verifies that custom actions are properly registered with the runtime.\n     * This is important to ensure actions are available for the agent to use.\n     */\n    {\n      name: 'should_have_hello_world_action',\n      fn: async (runtime) => {\n        // Access actions through runtime.actions instead of getPlugin\n        const actionExists = runtime.actions?.some((a) => a.name === 'HELLO_WORLD');\n        if (!actionExists) {\n          throw new Error('Hello world action not found in runtime actions');\n        }\n      },\n    },\n\n    /**\n     * Hello World Action Response Test\n     * ---------------------------------\n     * This test demonstrates a complete scenario where:\n     * 1. The agent is asked to say \"hello\"\n     * 2. The HELLO_WORLD action is triggered\n     * 3. The agent responds with text containing \"hello world\"\n     *\n     * This is a key pattern for testing agent behaviors - you simulate\n     * a user message and verify the agent's response.\n     */\n    {\n      name: 'hello_world_action_test',\n      fn: async (runtime) => {\n        // Create a test message asking the agent to say hello\n        const testMessage: Memory = {\n          entityId: '12345678-1234-1234-1234-123456789012' as UUID,\n          roomId: '12345678-1234-1234-1234-123456789012' as UUID,\n          content: {\n            text: 'Can you say hello?',\n            source: 'test',\n            actions: ['HELLO_WORLD'], // Specify which action we expect to trigger\n          },\n        };\n\n        // Create a test state (can include context if needed)\n        const testState: State = {\n          values: {},\n          data: {},\n          text: '',\n        };\n\n        let responseText = '';\n        let responseReceived = false;\n\n        // Find the hello world action in runtime.actions\n        const helloWorldAction = runtime.actions?.find((a) => a.name === 'HELLO_WORLD');\n        if (!helloWorldAction) {\n          throw new Error('Hello world action not found in runtime actions');\n        }\n\n        // Create a callback that captures the agent's response\n        // This simulates how the runtime would handle the action's response\n        const callback: HandlerCallback = async (response: Content) => {\n          responseReceived = true;\n          responseText = response.text || '';\n\n          // Verify the response includes the expected action\n          if (!response.actions?.includes('HELLO_WORLD')) {\n            throw new Error('Response did not include HELLO_WORLD action');\n          }\n\n          // Return Promise<Memory[]> as required by the HandlerCallback interface\n          return Promise.resolve([]);\n        };\n\n        // Execute the action - this simulates the runtime calling the action\n        await helloWorldAction.handler(runtime, testMessage, testState, {}, callback);\n\n        // Verify we received a response\n        if (!responseReceived) {\n          throw new Error('Hello world action did not produce a response');\n        }\n\n        // Verify the response contains \"hello world\" (case-insensitive)\n        if (!responseText.toLowerCase().includes('hello world')) {\n          throw new Error(`Expected response to contain \"hello world\" but got: \"${responseText}\"`);\n        }\n\n        // Success! The agent responded with \"hello world\" as expected\n      },\n    },\n\n    /**\n     * Provider Functionality Test\n     * ---------------------------\n     * Tests that providers can supply data to the agent when needed.\n     * Providers are used to fetch external data or compute values.\n     */\n    {\n      name: 'hello_world_provider_test',\n      fn: async (runtime) => {\n        // Create a test message\n        const testMessage: Memory = {\n          entityId: '12345678-1234-1234-1234-123456789012' as UUID,\n          roomId: '12345678-1234-1234-1234-123456789012' as UUID,\n          content: {\n            text: 'What can you provide?',\n            source: 'test',\n          },\n        };\n\n        // Create a test state\n        const testState: State = {\n          values: {},\n          data: {},\n          text: '',\n        };\n\n        // Find the hello world provider in runtime.providers\n        const helloWorldProvider = runtime.providers?.find(\n          (p) => p.name === 'HELLO_WORLD_PROVIDER'\n        );\n        if (!helloWorldProvider) {\n          throw new Error('Hello world provider not found in runtime providers');\n        }\n\n        // Test the provider\n        const result = await helloWorldProvider.get(runtime, testMessage, testState);\n\n        if (result.text !== 'I am a provider') {\n          throw new Error(`Expected provider to return \"I am a provider\", got \"${result.text}\"`);\n        }\n      },\n    },\n\n    /**\n     * Service Lifecycle Test\n     * ----------------------\n     * Verifies that services can be started, accessed, and stopped properly.\n     * Services run background tasks or manage long-lived resources.\n     */\n    {\n      name: 'starter_service_test',\n      fn: async (runtime) => {\n        // Get the service from the runtime\n        const service = runtime.getService('starter');\n        if (!service) {\n          throw new Error('Starter service not found');\n        }\n\n        // Check service capability description\n        if (\n          service.capabilityDescription !==\n          'This is a starter service which is attached to the agent through the starter plugin.'\n        ) {\n          throw new Error('Incorrect service capability description');\n        }\n\n        // Test service stop method\n        await service.stop();\n      },\n    },\n\n    /**\n     * ADD YOUR CUSTOM TESTS HERE\n     * --------------------------\n     * To add a new test:\n     *\n     * 1. Copy this template:\n     * ```typescript\n     * {\n     *   name: 'your_test_name',\n     *   fn: async (runtime) => {\n     *     // Setup: Create any test data needed\n     *\n     *     // Action: Perform the operation you want to test\n     *\n     *     // Assert: Check the results\n     *     if (result !== expected) {\n     *       throw new Error(`Expected ${expected} but got ${result}`);\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * 2. Common test patterns:\n     *    - Test action responses to specific prompts\n     *    - Verify provider data under different conditions\n     *    - Check service behavior during lifecycle events\n     *    - Validate plugin configuration handling\n     *    - Test error cases and edge conditions\n     *\n     * 3. Tips:\n     *    - Use meaningful variable names\n     *    - Include helpful error messages\n     *    - Test one thing per test\n     *    - Consider both success and failure scenarios\n     */\n  ],\n};\n\n// Export a default instance of the test suite for the E2E test runner\nexport default StarterPluginTestSuite;\n","import { starterPlugin } from './plugin.ts';\n\nexport { starterPlugin, StarterService } from './plugin.ts';\nexport default starterPlugin;\n"],"mappings":"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","names":["helloWorldAction","helloWorldProvider"]}