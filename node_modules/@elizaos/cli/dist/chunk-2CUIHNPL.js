import {
  buildProjectWithSpinner,
  copyTemplate,
  createTask,
  ensureElizaDir,
  getDisplayDirectory,
  installDependenciesWithSpinner,
  installPluginWithSpinner,
  promptAndStoreAnthropicKey,
  promptAndStoreGoogleKey,
  promptAndStoreOllamaConfig,
  promptAndStoreOllamaEmbeddingConfig,
  promptAndStoreOpenAIKey,
  promptAndStoreOpenRouterKey,
  promptAndStorePostgresUrl,
  runTasks,
  setupPgLite
} from "./chunk-2ALAPQLV.js";

// src/characters/eliza.ts
var baseCharacter = {
  name: "Eliza",
  plugins: ["@elizaos/plugin-sql", "@elizaos/plugin-bootstrap"],
  secrets: {},
  settings: {
    avatar: "https://elizaos.github.io/eliza-avatars/Eliza/portrait.png"
  },
  system: "Respond to all messages in a helpful, conversational manner. Provide assistance on a wide range of topics, using knowledge when needed. Be concise but thorough, friendly but professional. Use humor when appropriate and be empathetic to user needs. Provide valuable information and insights when questions are asked.",
  bio: [
    "Engages with all types of questions and conversations",
    "Provides helpful, concise responses",
    "Uses knowledge resources effectively when needed",
    "Balances brevity with completeness",
    "Uses humor and empathy appropriately",
    "Adapts tone to match the conversation context",
    "Offers assistance proactively",
    "Communicates clearly and directly"
  ],
  topics: [
    "general knowledge and information",
    "problem solving and troubleshooting",
    "technology and software",
    "community building and management",
    "business and productivity",
    "creativity and innovation",
    "personal development",
    "communication and collaboration",
    "education and learning",
    "entertainment and media"
  ],
  messageExamples: [
    [
      {
        name: "{{name1}}",
        content: {
          text: "This user keeps derailing technical discussions with personal problems."
        }
      },
      {
        name: "Eliza",
        content: {
          text: "DM them. Sounds like they need to talk about something else."
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "I tried, they just keep bringing drama back to the main channel."
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Send them my way. I've got time today."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "I can't handle being a mod anymore. It's affecting my mental health."
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Drop the channels. You come first."
        }
      },
      {
        name: "{{name1}}",
        content: {
          text: "But who's going to handle everything?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "We will. Take the break. Come back when you're ready."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Could you explain how blockchain technology works?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "A blockchain is a distributed database that maintains a growing list of records secured against tampering and revision. Think of it as a chain of blocks where each block contains data, its own hash, and the hash of the previous block."
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Hey everyone, what are our community guidelines for new members?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Let me check our guidelines.",
          providers: ["KNOWLEDGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "Are there any resources for onboarding new developers to our community?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "We have some documentation I can find for you.",
          providers: ["KNOWLEDGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "What process should we follow for handling code of conduct violations?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Let me pull up our violation handling process.",
          providers: ["KNOWLEDGE"]
        }
      }
    ],
    [
      {
        name: "{{name1}}",
        content: {
          text: "What can you tell me about quantum computing?"
        }
      },
      {
        name: "Eliza",
        content: {
          text: "Let me find some information about quantum computing.",
          providers: ["KNOWLEDGE"]
        }
      }
    ]
  ],
  postExamples: [
    "Sometimes the best debugging tool is a fresh cup of coffee and a walk around the block.",
    "The magic happens when developers stop competing and start collaborating. Build together, grow together.",
    "Reminder: Your code doesn't have to be perfect on the first try. Progress over perfection.",
    "Community tip: The person asking 'obvious' questions today might solve your toughest problem tomorrow. Be kind.",
    "Hot take: Good documentation is more valuable than clever code.",
    "The best feature you can add to your project? A welcoming community.",
    "Debugging is just a conversation with your past self. Make it easier by leaving good comments.",
    "Your daily reminder that impostor syndrome affects even the most experienced developers. You belong here.",
    "Pro tip: Read the error message. Then read it again. The answer is usually there.",
    "Building in public isn't about showing off. It's about learning together and helping others avoid your mistakes.",
    "The difference between junior and senior developers? Seniors know when NOT to write code.",
    "Community > Competition. Always.",
    "Remember: Every expert was once a beginner who refused to give up.",
    "Code reviews aren't personal attacks. They're opportunities to level up together.",
    "The most powerful tool in development? Asking for help when you need it."
  ],
  style: {
    all: [
      "Keep responses concise but informative",
      "Use clear and direct language",
      "Be engaging and conversational",
      "Use humor when appropriate",
      "Be empathetic and understanding",
      "Provide helpful information",
      "Be encouraging and positive",
      "Adapt tone to the conversation",
      "Use knowledge resources when needed",
      "Respond to all types of questions"
    ],
    chat: [
      "Be conversational and natural",
      "Engage with the topic at hand",
      "Be helpful and informative",
      "Show personality and warmth"
    ],
    post: [
      "Keep it concise and punchy - every word counts",
      "Share insights, not platitudes",
      "Be authentic and conversational, not corporate",
      "Use specific examples over generic advice",
      "Add value with each post - teach, inspire, or entertain",
      "One clear thought per post",
      "Avoid excessive hashtags or mentions",
      "Write like you are talking to a friend",
      "Share personal observations and hot takes",
      "Be helpful without being preachy",
      "Use emojis sparingly and purposefully",
      "End with something thought-provoking when appropriate"
    ]
  }
};
function getElizaCharacter() {
  const plugins = [
    // Core plugins first
    "@elizaos/plugin-sql",
    // Text-only plugins (no embedding support)
    ...process.env.ANTHROPIC_API_KEY?.trim() ? ["@elizaos/plugin-anthropic"] : [],
    ...process.env.OPENROUTER_API_KEY?.trim() ? ["@elizaos/plugin-openrouter"] : [],
    // Embedding-capable plugins (before platform plugins per documented order)
    ...process.env.OPENAI_API_KEY?.trim() ? ["@elizaos/plugin-openai"] : [],
    ...process.env.GOOGLE_GENERATIVE_AI_API_KEY?.trim() ? ["@elizaos/plugin-google-genai"] : [],
    // Platform plugins
    ...process.env.DISCORD_API_TOKEN?.trim() ? ["@elizaos/plugin-discord"] : [],
    ...process.env.TWITTER_API_KEY?.trim() && process.env.TWITTER_API_SECRET_KEY?.trim() && process.env.TWITTER_ACCESS_TOKEN?.trim() && process.env.TWITTER_ACCESS_TOKEN_SECRET?.trim() ? ["@elizaos/plugin-twitter"] : [],
    ...process.env.TELEGRAM_BOT_TOKEN?.trim() ? ["@elizaos/plugin-telegram"] : [],
    // Bootstrap plugin
    ...!process.env.IGNORE_BOOTSTRAP ? ["@elizaos/plugin-bootstrap"] : [],
    // Only include Ollama as fallback if no other LLM providers are configured
    ...!process.env.ANTHROPIC_API_KEY?.trim() && !process.env.OPENROUTER_API_KEY?.trim() && !process.env.OPENAI_API_KEY?.trim() && !process.env.GOOGLE_GENERATIVE_AI_API_KEY?.trim() ? ["@elizaos/plugin-ollama"] : []
  ];
  return {
    ...baseCharacter,
    plugins
  };
}

// src/commands/create/actions/creators.ts
import { join } from "path";
import fs3 from "fs/promises";
import * as clack2 from "@clack/prompts";
import colors from "yoctocolors";

// src/commands/create/utils/validation.ts
import { existsSync } from "fs";
import fs from "fs/promises";
import { z as z2 } from "zod";

// src/commands/create/types.ts
import { z } from "zod";
var initOptionsSchema = z.object({
  yes: z.boolean().default(false),
  type: z.enum(["project", "plugin", "agent", "tee"]).default("project")
});

// src/commands/create/utils/validation.ts
var ProjectNameSchema = z2.string().min(1, "Invalid project name: cannot be empty").regex(
  /^[a-z0-9-_]+$/,
  "Invalid project name: must contain only lowercase letters, numbers, hyphens, and underscores"
).refine(
  (name) => !name.startsWith("-") && !name.endsWith("-"),
  "Invalid project name: cannot start or end with a hyphen"
).refine(
  (name) => !name.startsWith("_") && !name.endsWith("_"),
  "Invalid project name: cannot start or end with an underscore"
);
var PluginNameSchema = z2.string().min(1, "Plugin name cannot be empty").regex(
  /^[a-z0-9-_]+$/,
  "Plugin name must contain only lowercase letters, numbers, hyphens, and underscores"
).refine(
  (name) => !name.startsWith("-") && !name.endsWith("-"),
  "Plugin name cannot start or end with a hyphen"
).refine(
  (name) => !name.startsWith("_") && !name.endsWith("_"),
  "Plugin name cannot start or end with an underscore"
);
function validateCreateOptions(options) {
  try {
    return initOptionsSchema.parse(options);
  } catch (error) {
    if (error instanceof z2.ZodError) {
      const typeError = error.errors.find(
        (e) => e.path.includes("type") && e.code === "invalid_enum_value"
      );
      if (typeError && "received" in typeError) {
        const enumError = typeError;
        throw new Error(
          `Invalid type '${enumError.received}'. Expected: ${enumError.options?.join(", ")}`
        );
      }
    }
    throw error;
  }
}
function validateProjectName(name) {
  if (name === ".") {
    return { isValid: true };
  }
  try {
    ProjectNameSchema.parse(name);
    return { isValid: true };
  } catch (error) {
    if (error instanceof z2.ZodError) {
      return { isValid: false, error: error.errors[0].message };
    }
    return { isValid: false, error: "Invalid project name" };
  }
}
function processPluginName(name) {
  try {
    let processedName = name.replace(/^(eliza-?|elizaos-?|plugin-?)/i, "").replace(/(-?plugin|-?eliza|-?elizaos)$/i, "").toLowerCase().replace(/[^a-z0-9-_]/g, "-").replace(/-+/g, "-").replace(/^-+|-+$/g, "");
    if (!processedName) {
      return { isValid: false, error: "Plugin name cannot be empty after processing" };
    }
    PluginNameSchema.parse(processedName);
    return { isValid: true, processedName };
  } catch (error) {
    if (error instanceof z2.ZodError) {
      return { isValid: false, error: error.errors[0].message };
    }
    return { isValid: false, error: "Invalid plugin name" };
  }
}
async function validateTargetDirectory(targetDir) {
  try {
    if (!existsSync(targetDir)) {
      return { isValid: true };
    }
    const entries = await fs.readdir(targetDir);
    if (entries.length > 0) {
      return {
        isValid: false,
        error: `Directory ${targetDir} already exists and is not empty. Please choose an empty directory or a new name.`
      };
    }
    return { isValid: true };
  } catch (error) {
    return {
      isValid: false,
      error: `Failed to validate directory: ${error instanceof Error ? error.message : "Unknown error"}`
    };
  }
}

// src/commands/create/utils/selection.ts
import * as clack from "@clack/prompts";
function getAvailableAIModels() {
  return [
    {
      title: "Local AI (Ollama)",
      value: "local",
      description: "Local models via Ollama, no API required"
    },
    {
      title: "OpenAI",
      value: "openai",
      description: "GPT-4 models"
    },
    {
      title: "Anthropic",
      value: "claude",
      description: "Claude models"
    },
    {
      title: "OpenRouter",
      value: "openrouter",
      description: "Access multiple AI models"
    },
    {
      title: "Google Generative AI",
      value: "google",
      description: "Gemini models"
    }
  ];
}
function hasEmbeddingSupport(aiModel) {
  const modelsWithEmbeddings = ["local", "openai", "google"];
  return modelsWithEmbeddings.includes(aiModel);
}
function getAvailableDatabases() {
  return [
    {
      title: "Pglite (Pglite)",
      value: "pglite",
      description: "Local development"
    },
    {
      title: "PostgreSQL",
      value: "postgres",
      description: "Production database"
    }
  ];
}
async function selectDatabase() {
  const availableDatabases = getAvailableDatabases();
  const database = await clack.select({
    message: "Which database would you like to use?",
    options: availableDatabases.map((db) => ({
      label: db.title,
      value: db.value,
      hint: db.description
    })),
    initialValue: "pglite"
  });
  if (clack.isCancel(database)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  return database;
}
async function selectAIModel() {
  const availableModels = getAvailableAIModels();
  const aiModel = await clack.select({
    message: "Which AI model would you like to use?",
    options: availableModels.map((model) => ({
      label: model.title,
      value: model.value,
      hint: model.description
    })),
    initialValue: "local"
  });
  if (clack.isCancel(aiModel)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  return aiModel;
}
function getAvailableEmbeddingModels() {
  return [
    {
      title: "Local AI (Ollama)",
      value: "local",
      description: "Local embeddings via Ollama, no API required"
    },
    {
      title: "OpenAI",
      value: "openai",
      description: "OpenAI text-embedding-ada-002"
    },
    {
      title: "Google Generative AI",
      value: "google",
      description: "Google embedding models"
    }
  ];
}
async function selectEmbeddingModel() {
  const availableModels = getAvailableEmbeddingModels();
  const embeddingModel = await clack.select({
    message: "Select an embedding model (required since your AI model doesn't support embeddings):",
    options: availableModels.map((model) => ({
      label: model.title,
      value: model.value,
      hint: model.description
    })),
    initialValue: "local"
  });
  if (clack.isCancel(embeddingModel)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  return embeddingModel;
}

// src/commands/create/actions/setup.ts
import { existsSync as existsSync2 } from "fs";
import fs2 from "fs/promises";
async function createProjectDirectories(targetDir) {
  await ensureElizaDir(targetDir);
}
async function setupAIModelConfig(aiModel, envFilePath, isNonInteractive = false) {
  try {
    switch (aiModel) {
      case "local": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# Local AI Configuration (using Ollama)\n";
          content += "OLLAMA_API_ENDPOINT=http://localhost:11434\n";
          content += "OLLAMA_MODEL=gemma3\n";
          content += "OLLAMA_EMBEDDING_MODEL=nomic-embed-text\n";
          content += "USE_OLLAMA_TEXT_MODELS=true\n";
          content += "# Make sure Ollama is installed and running: https://ollama.ai/\n";
          content += "# Pull models with: ollama pull gemma3 && ollama pull nomic-embed-text\n";
          await fs2.writeFile(envFilePath, content, "utf8");
        } else {
          await promptAndStoreOllamaConfig(envFilePath);
          await promptAndStoreOllamaEmbeddingConfig(envFilePath);
        }
        break;
      }
      case "openai": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# OpenAI Configuration\n";
          content += "OPENAI_API_KEY=your_openai_api_key_here\n";
          content += "# Get your API key from: https://platform.openai.com/api-keys\n";
          await fs2.writeFile(envFilePath, content, "utf8");
        } else {
          await promptAndStoreOpenAIKey(envFilePath);
        }
        break;
      }
      case "claude": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# Anthropic API Configuration\n";
          content += "ANTHROPIC_API_KEY=your_anthropic_api_key_here\n";
          content += "# Get your API key from: https://console.anthropic.com/\n";
          await fs2.writeFile(envFilePath, content, "utf8");
        } else {
          await promptAndStoreAnthropicKey(envFilePath);
        }
        break;
      }
      case "openrouter": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# OpenRouter Configuration\n";
          content += "OPENROUTER_API_KEY=your_openrouter_api_key_here\n";
          content += "# Get your API key from: https://openrouter.ai/keys\n";
          await fs2.writeFile(envFilePath, content, "utf8");
        } else {
          await promptAndStoreOpenRouterKey(envFilePath);
        }
        break;
      }
      case "google": {
        if (isNonInteractive) {
          let content = "";
          if (existsSync2(envFilePath)) {
            content = await fs2.readFile(envFilePath, "utf8");
          }
          if (content && !content.endsWith("\n")) {
            content += "\n";
          }
          content += "\n# AI Model Configuration\n";
          content += "# Google Generative AI Configuration\n";
          content += "GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key_here\n";
          content += "# Get your API key from: https://aistudio.google.com/apikey\n";
          await fs2.writeFile(envFilePath, content, "utf8");
        } else {
          await promptAndStoreGoogleKey(envFilePath);
        }
        break;
      }
      default:
        console.warn(`Unknown AI model: ${aiModel}, skipping configuration`);
        return;
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`Failed to set up AI model configuration: ${errorMessage}`);
  }
}
function hasValidApiKey(content, keyName) {
  const regex = new RegExp(`^${keyName}=(.+)$`, "m");
  const match = content.match(regex);
  if (!match) return false;
  const value = match[1].trim();
  return value !== "" && !value.includes("your_") && !value.includes("_here") && !value.includes("PLACEHOLDER") && !value.includes("placeholder");
}
async function setupEmbeddingModelConfig(embeddingModel, envFilePath, isNonInteractive = false) {
  try {
    let content = "";
    if (existsSync2(envFilePath)) {
      content = await fs2.readFile(envFilePath, "utf8");
    }
    if (content && !content.endsWith("\n")) {
      content += "\n";
    }
    switch (embeddingModel) {
      case "local": {
        if (!hasValidApiKey(content, "OLLAMA_API_ENDPOINT")) {
          if (isNonInteractive) {
            if (!content.includes("OLLAMA_API_ENDPOINT=")) {
              content += "\n# Embedding Model Configuration (Fallback)\n";
              content += "# Ollama Embeddings Configuration\n";
              content += "OLLAMA_API_ENDPOINT=http://localhost:11434\n";
              content += "OLLAMA_EMBEDDING_MODEL=nomic-embed-text\n";
              content += "USE_OLLAMA_EMBEDDINGS=true\n";
              content += "# Make sure Ollama is installed and running: https://ollama.ai/\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
          } else {
            await promptAndStoreOllamaEmbeddingConfig(envFilePath);
          }
        } else {
          if (isNonInteractive) {
            if (!content.includes("OLLAMA_EMBEDDING_MODEL")) {
              content += "OLLAMA_EMBEDDING_MODEL=nomic-embed-text\n";
            }
            if (!content.includes("USE_OLLAMA_EMBEDDINGS")) {
              content += "USE_OLLAMA_EMBEDDINGS=true\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
          } else {
            await promptAndStoreOllamaEmbeddingConfig(envFilePath);
          }
        }
        break;
      }
      case "openai": {
        if (!hasValidApiKey(content, "OPENAI_API_KEY")) {
          if (isNonInteractive) {
            if (!content.includes("OPENAI_API_KEY=")) {
              content += "\n# Embedding Model Configuration (Fallback)\n";
              content += "# OpenAI Embeddings Configuration\n";
              content += "OPENAI_API_KEY=your_openai_api_key_here\n";
              content += "# Get your API key from: https://platform.openai.com/api-keys\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
          } else {
            await promptAndStoreOpenAIKey(envFilePath);
          }
        }
        break;
      }
      case "google": {
        if (!hasValidApiKey(content, "GOOGLE_GENERATIVE_AI_API_KEY")) {
          if (isNonInteractive) {
            if (!content.includes("GOOGLE_GENERATIVE_AI_API_KEY=")) {
              content += "\n# Embedding Model Configuration (Fallback)\n";
              content += "# Google Generative AI Embeddings Configuration\n";
              content += "GOOGLE_GENERATIVE_AI_API_KEY=your_google_api_key_here\n";
              content += "# Get your API key from: https://aistudio.google.com/apikey\n";
            }
            await fs2.writeFile(envFilePath, content, "utf8");
          } else {
            await promptAndStoreGoogleKey(envFilePath);
          }
        }
        break;
      }
      default:
        console.warn(`Unknown embedding model: ${embeddingModel}, skipping configuration`);
        return;
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error";
    console.error(`Failed to set up embedding model configuration: ${errorMessage}`);
  }
}
function resolveModelToPlugin(modelName) {
  const modelToPlugin = {
    openai: "openai",
    claude: "anthropic",
    anthropic: "anthropic",
    openrouter: "openrouter",
    local: "ollama",
    // 'local' maps to ollama plugin
    google: "google-genai"
  };
  return modelToPlugin[modelName] || null;
}
async function installModelPlugin(modelName, targetDir, purpose = "") {
  const pluginName = resolveModelToPlugin(modelName);
  if (!pluginName) {
    return;
  }
  await installPluginWithSpinner(pluginName, targetDir, purpose);
}
async function setupProjectEnvironment(targetDir, database, aiModel, embeddingModel, isNonInteractive = false) {
  await createProjectDirectories(targetDir);
  const envFilePath = `${targetDir}/.env`;
  if (database === "postgres") {
    if (!isNonInteractive) {
      await promptAndStorePostgresUrl(envFilePath);
    }
  } else if (database === "pglite") {
    await setupPgLite(void 0, `${targetDir}/.env`, targetDir);
  }
  if (!isNonInteractive) {
    await setupAIModelConfig(aiModel, envFilePath, isNonInteractive);
    if (embeddingModel) {
      await setupEmbeddingModelConfig(embeddingModel, envFilePath, isNonInteractive);
    }
  }
  await installModelPlugin(aiModel, targetDir, aiModel === "local" ? "for local AI" : "");
  if (embeddingModel && embeddingModel !== "local") {
    const aiPluginName = resolveModelToPlugin(aiModel);
    const embeddingPluginName = resolveModelToPlugin(embeddingModel);
    if (embeddingPluginName && embeddingPluginName !== aiPluginName) {
      await installModelPlugin(embeddingModel, targetDir, "for embeddings");
    }
  } else if (embeddingModel === "local") {
    if (aiModel !== "local") {
      await installModelPlugin(embeddingModel, targetDir, "for embeddings");
    }
  }
}

// src/commands/create/actions/creators.ts
import { existsSync as existsSync3, rmSync } from "fs";
async function handleInteractiveConfiguration(targetDir, database, aiModel, embeddingModel) {
  const envFilePath = `${targetDir}/.env`;
  if (database === "postgres") {
    await promptAndStorePostgresUrl(envFilePath);
  }
  if (aiModel !== "local" || embeddingModel) {
    if (aiModel !== "local") {
      await setupAIModelConfig(aiModel, envFilePath, false);
    }
    if (embeddingModel) {
      await setupEmbeddingModelConfig(embeddingModel, envFilePath, false);
    }
  }
}
async function withCleanupOnInterrupt(targetDir, displayName, fn) {
  const directoryExistedBefore = existsSync3(targetDir);
  const cleanup = () => {
    if (!directoryExistedBefore && existsSync3(targetDir)) {
      console.info(colors.red(`

Interrupted! Cleaning up ${displayName}...`));
      try {
        rmSync(targetDir, { recursive: true, force: true });
        console.info("Cleanup completed.");
      } catch (error) {
        console.error(colors.red("Error during cleanup:"), error);
      }
    }
  };
  const sigintHandler = () => {
    process.exit(130);
  };
  const sigtermHandler = () => {
    process.exit(143);
  };
  process.on("exit", cleanup);
  process.on("SIGINT", sigintHandler);
  process.on("SIGTERM", sigtermHandler);
  try {
    const result = await fn();
    process.removeListener("exit", cleanup);
    process.removeListener("SIGINT", sigintHandler);
    process.removeListener("SIGTERM", sigtermHandler);
    return result;
  } catch (error) {
    process.removeListener("exit", cleanup);
    process.removeListener("SIGINT", sigintHandler);
    process.removeListener("SIGTERM", sigtermHandler);
    if (!directoryExistedBefore && existsSync3(targetDir)) {
      try {
        console.info(colors.red(`
Cleaning up due to error...`));
        rmSync(targetDir, { recursive: true, force: true });
      } catch (cleanupError) {
      }
    }
    throw error;
  }
}
async function createPlugin(pluginName, targetDir, pluginType = "full", isNonInteractive = false) {
  const nameResult = processPluginName(pluginName);
  if (!nameResult.isValid) {
    throw new Error(nameResult.error || "Invalid plugin name");
  }
  const processedName = nameResult.processedName;
  const pluginDirName = processedName.startsWith("plugin-") ? processedName : `plugin-${processedName}`;
  if (pluginDirName !== pluginName) {
    console.warn(
      `
Warning: changing "${pluginName}" to "${pluginDirName}" to conform to plugin naming conventions
`
    );
  }
  const pluginTargetDir = join(targetDir, pluginDirName);
  const dirResult = await validateTargetDirectory(pluginTargetDir);
  if (!dirResult.isValid) {
    throw new Error(dirResult.error || "Invalid target directory");
  }
  if (!isNonInteractive) {
    const displayDir = getDisplayDirectory(targetDir);
    const confirmCreate = await clack2.confirm({
      message: `Create plugin "${pluginDirName}" in ${displayDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("Plugin creation cancelled.");
      process.exit(0);
    }
  }
  await withCleanupOnInterrupt(pluginTargetDir, pluginDirName, async () => {
    const templateName = pluginType === "quick" ? "plugin-quick" : "plugin";
    await runTasks([
      createTask(
        "Copying plugin template",
        () => copyTemplate(templateName, pluginTargetDir)
      ),
      createTask("Installing dependencies", () => installDependenciesWithSpinner(pluginTargetDir))
    ]);
    console.info(`
${colors.green("\u2713")} Plugin "${pluginDirName}" created successfully!`);
    console.info(`
Next steps:`);
    console.info(`  cd ${pluginDirName}`);
    console.info(`  bun run build   # Build the plugin`);
    console.info(`
  Common commands:`);
    console.info(`  elizaos dev    # Start development mode with hot reloading`);
    console.info(`  elizaos start  # Start in production mode
`);
  });
}
async function createAgent(agentName, targetDir, isNonInteractive = false) {
  const agentFilePath = join(targetDir, `${agentName}.json`);
  try {
    await fs3.access(agentFilePath);
    throw new Error(`Agent file ${agentFilePath} already exists`);
  } catch (error) {
    if (error.code !== "ENOENT") {
      throw error;
    }
  }
  if (!isNonInteractive) {
    const displayDir = getDisplayDirectory(targetDir);
    const confirmCreate = await clack2.confirm({
      message: `Create agent "${agentName}" in ${displayDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("Agent creation cancelled.");
      process.exit(0);
    }
  }
  const agentCharacter = {
    ...getElizaCharacter(),
    name: agentName,
    bio: [
      `${agentName} is a helpful AI assistant created to provide assistance and engage in meaningful conversations.`,
      `${agentName} is knowledgeable, creative, and always eager to help users with their questions and tasks.`
    ]
  };
  await fs3.writeFile(agentFilePath, JSON.stringify(agentCharacter, null, 2));
  console.info(`
${colors.green("\u2713")} Agent "${agentName}" created successfully!`);
  console.info(`Agent character created successfully at: ${agentFilePath}`);
  console.info(`
To use this agent:`);
  console.info(`  1. Start ElizaOS server with this character:`);
  console.info(`     elizaos start --character ${agentFilePath}`);
  console.info(`
  OR if a server is already running:`);
  console.info(`     elizaos agent start --path ${agentFilePath}`);
}
async function createTEEProject(projectName, targetDir, database, aiModel, embeddingModel, isNonInteractive = false) {
  delete process.env.PGLITE_DATA_DIR;
  const teeTargetDir = join(targetDir, projectName);
  const dirResult = await validateTargetDirectory(teeTargetDir);
  if (!dirResult.isValid) {
    throw new Error(dirResult.error || "Invalid target directory");
  }
  if (!isNonInteractive) {
    const displayDir = getDisplayDirectory(targetDir);
    const confirmCreate = await clack2.confirm({
      message: `Create TEE project "${projectName}" in ${displayDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("TEE project creation cancelled.");
      process.exit(0);
    }
  }
  await withCleanupOnInterrupt(teeTargetDir, projectName, async () => {
    await fs3.mkdir(teeTargetDir, { recursive: true });
    if (!isNonInteractive) {
      await handleInteractiveConfiguration(teeTargetDir, database, aiModel, embeddingModel);
    }
    await runTasks([
      createTask(
        "Copying TEE template",
        () => copyTemplate("project-tee-starter", teeTargetDir)
      ),
      createTask(
        "Setting up project environment",
        () => setupProjectEnvironment(teeTargetDir, database, aiModel, embeddingModel, true)
      ),
      createTask("Installing dependencies", () => installDependenciesWithSpinner(teeTargetDir)),
      createTask("Building project", () => buildProjectWithSpinner(teeTargetDir, false))
    ]);
    console.info(`
${colors.green("\u2713")} TEE project "${projectName}" created successfully!`);
    console.info(`
Next steps:`);
    console.info(`  cd ${projectName}`);
    console.info(`
  Common commands:`);
    console.info(`  elizaos dev    # Start development mode with hot reloading`);
    console.info(`  elizaos start  # Start in production mode
`);
  });
}
async function createProject(projectName, targetDir, database, aiModel, embeddingModel, isNonInteractive = false) {
  delete process.env.PGLITE_DATA_DIR;
  const projectTargetDir = projectName === "." ? targetDir : join(targetDir, projectName);
  const dirResult = await validateTargetDirectory(projectTargetDir);
  if (!dirResult.isValid) {
    throw new Error(dirResult.error || "Invalid target directory");
  }
  if (!isNonInteractive) {
    const displayDir = getDisplayDirectory(targetDir);
    const displayProjectName = projectName === "." ? "project" : `project "${projectName}"`;
    const confirmCreate = await clack2.confirm({
      message: `Create ${displayProjectName} in ${displayDir}?`
    });
    if (clack2.isCancel(confirmCreate) || !confirmCreate) {
      clack2.cancel("Project creation cancelled.");
      process.exit(0);
    }
  }
  const createFn = async () => {
    if (projectName !== ".") {
      await fs3.mkdir(projectTargetDir, { recursive: true });
    }
    if (!isNonInteractive) {
      await handleInteractiveConfiguration(projectTargetDir, database, aiModel, embeddingModel);
    }
    await runTasks([
      createTask(
        "Copying project template",
        () => copyTemplate("project-starter", projectTargetDir)
      ),
      createTask(
        "Setting up project environment",
        () => setupProjectEnvironment(projectTargetDir, database, aiModel, embeddingModel, true)
      ),
      createTask("Installing dependencies", () => installDependenciesWithSpinner(projectTargetDir)),
      createTask("Building project", () => buildProjectWithSpinner(projectTargetDir, false))
    ]);
    const displayName = projectName === "." ? "Project" : `Project "${projectName}"`;
    console.info(`
${colors.green("\u2713")} ${displayName} initialized successfully!`);
    console.info(`
Next steps:`);
    if (projectName !== ".") {
      console.info(`  cd ${projectName}`);
    }
    console.info(`
  Common commands:`);
    console.info(`  elizaos dev    # Start development mode with hot reloading`);
    console.info(`  elizaos start  # Start in production mode
`);
  };
  if (projectName === ".") {
    await createFn();
  } else {
    await withCleanupOnInterrupt(projectTargetDir, projectName, createFn);
  }
}

export {
  validateCreateOptions,
  validateProjectName,
  hasEmbeddingSupport,
  selectDatabase,
  selectAIModel,
  selectEmbeddingModel,
  getElizaCharacter,
  createProjectDirectories,
  setupAIModelConfig,
  hasValidApiKey,
  setupEmbeddingModelConfig,
  setupProjectEnvironment,
  createPlugin,
  createAgent,
  createTEEProject,
  createProject
};
