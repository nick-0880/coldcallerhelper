#!/usr/bin/env bun
import {
  create
} from "./chunk-I77ZRNYO.js";
import {
  getElizaCharacter
} from "./chunk-2CUIHNPL.js";
import {
  TestRunner,
  UserEnvironment,
  agent,
  buildProject,
  checkAndShowUpdateNotification,
  configureDatabaseSettings,
  createEnvFileService,
  detectDirectoryType,
  detectPluginContext,
  displayBanner,
  fetchPluginRegistry,
  findNextAvailablePort,
  getCliInstallTag,
  getGitHubCredentials,
  getModuleLoader,
  getPackageManager,
  getRegistrySettings,
  getVersion,
  handleError,
  initializeDataDir,
  installPlugin,
  isCliInstalledViaNpm,
  isRunningViaBunx,
  isRunningViaNpx,
  isValidForUpdates,
  loadPluginModule,
  logHeader,
  migrateCliToBun,
  normalizePluginName,
  provideLocalPluginGuidance,
  publishToGitHub,
  resolvePgliteDir,
  saveRegistrySettings,
  testPublishToGitHub,
  testPublishToNpm,
  tryDelegateToLocalCli,
  validateDataDir
} from "./chunk-2ALAPQLV.js";
import {
  configureEmojis,
  emoji,
  runBunCommand
} from "./chunk-FDEDLANP.js";
import "./chunk-4O6EZU37.js";
import {
  bunExec,
  bunExecInherit,
  bunExecSimple
} from "./chunk-D3Q2UZLZ.js";
import "./chunk-3RG5ZIWI.js";

// src/commands/dev/index.ts
import { Command, Option } from "commander";

// src/commands/dev/utils/build-utils.ts
import { existsSync } from "fs";
import path from "path";
async function buildPackage(packagePath, isPlugin2) {
  const startTime = Date.now();
  try {
    await buildProject(packagePath, isPlugin2);
    const duration = Date.now() - startTime;
    return { success: true, duration };
  } catch (error) {
    const duration = Date.now() - startTime;
    return { success: false, duration, error };
  }
}
async function buildCorePackages(monorepoRoot) {
  const corePackages = [
    {
      name: "core",
      path: path.join(monorepoRoot, "packages", "core"),
      isPlugin: false
    },
    {
      name: "client",
      path: path.join(monorepoRoot, "packages", "client"),
      isPlugin: false
    },
    {
      name: "plugin-bootstrap",
      path: path.join(monorepoRoot, "packages", "plugin-bootstrap"),
      isPlugin: true
    }
  ];
  const results = [];
  for (const pkg of corePackages) {
    console.info(`Building ${pkg.name}...`);
    const result = await buildPackage(pkg.path, pkg.isPlugin);
    if (!result.success) {
      console.error(`Error building ${pkg.name}: ${result.error?.message}`);
    } else {
      console.info(`\u2713 Built ${pkg.name} (${result.duration}ms)`);
    }
    results.push(result);
  }
  return results;
}
async function performRebuild(context) {
  console.info("Rebuilding...");
  const { directory, directoryType } = context;
  const isPlugin2 = directoryType.type === "elizaos-plugin";
  const isMonorepo = directoryType.type === "elizaos-monorepo";
  if (isMonorepo || directoryType.monorepoRoot) {
    const { monorepoRoot } = await UserEnvironment.getInstance().getPathInfo();
    if (monorepoRoot) {
      await buildCorePackages(monorepoRoot);
    } else {
      console.warn("Monorepo context detected, but failed to find monorepo root.");
    }
  }
  const result = await buildPackage(directory, isPlugin2);
  if (result.success) {
    console.log(`\u2713 Rebuild successful (${result.duration}ms)`);
  } else {
    console.error(`Build failed: ${result.error?.message}`);
    throw result.error;
  }
}
async function performInitialBuild(context) {
  const { directoryType, directory } = context;
  const isPlugin2 = directoryType.type === "elizaos-plugin";
  const isMonorepo = directoryType.type === "elizaos-monorepo";
  if (process.env.ELIZA_TEST_MODE) {
    console.info("Skipping initial build in test mode");
    return;
  }
  if (!isMonorepo) {
    console.info("Building project...");
    try {
      await buildProject(directory, isPlugin2);
      console.info("\u2713 Initial build completed");
    } catch (error) {
      console.error(
        `Initial build failed: ${error instanceof Error ? error.message : String(error)}`
      );
      console.info("Continuing with dev mode anyway...");
    }
  } else {
    console.info(
      "Monorepo detected - skipping automatic build. Use specific package build commands as needed."
    );
  }
}
function createDevContext(cwd) {
  const directoryType = detectDirectoryType(cwd);
  if (!directoryType) {
    throw new Error(
      "Cannot start development mode in this directory. Directory is not accessible or does not exist."
    );
  }
  const srcDir = path.join(cwd, "src");
  return {
    directory: cwd,
    directoryType,
    watchDirectory: existsSync(srcDir) ? srcDir : cwd,
    buildRequired: directoryType.type !== "elizaos-monorepo"
  };
}

// src/commands/dev/utils/file-watcher.ts
import chokidar from "chokidar";
import { existsSync as existsSync2, readdirSync } from "fs";
import path2 from "path";
var DEFAULT_WATCHER_CONFIG = {
  ignored: ["**/node_modules/**", "**/dist/**", "**/.git/**"],
  ignoreInitial: true,
  persistent: true,
  followSymlinks: false,
  depth: 99,
  // Set high depth to ensure we catch all nested files
  usePolling: false,
  // Only use polling if necessary
  interval: 1e3
  // Poll every second
};
function findTsFiles(dir, watchDir) {
  let results = [];
  try {
    const entries = readdirSync(dir, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path2.join(dir, entry.name);
      if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules" && entry.name !== "dist") {
        results = results.concat(findTsFiles(fullPath, watchDir));
      } else if (entry.isFile() && (entry.name.endsWith(".ts") || entry.name.endsWith(".js") || entry.name.endsWith(".tsx") || entry.name.endsWith(".jsx"))) {
        results.push(path2.relative(watchDir, fullPath));
      }
    }
  } catch (error) {
  }
  return results;
}
async function watchDirectory(dir, onChange, config2 = {}) {
  try {
    const absoluteDir = path2.resolve(dir);
    const srcDir = path2.join(absoluteDir, "src");
    const dirToWatch = existsSync2(srcDir) ? srcDir : absoluteDir;
    const watchOptions = { ...DEFAULT_WATCHER_CONFIG, ...config2 };
    const watcher = chokidar.watch(dirToWatch, watchOptions);
    const tsFiles = findTsFiles(dirToWatch, dirToWatch);
    console.info(`Found ${tsFiles.length} TypeScript/JavaScript files in the watched directory`);
    if (tsFiles.length > 0) {
      console.info(
        `Sample files: ${tsFiles.slice(0, 3).join(", ")}${tsFiles.length > 3 ? "..." : ""}`
      );
    }
    let debounceTimer = null;
    watcher.on("ready", () => {
      const watchedPaths = watcher.getWatched();
      const pathsCount = Object.keys(watchedPaths).length;
      if (pathsCount === 0) {
        console.warn("No directories are being watched! File watching may not be working.");
        watcher.add(`${dirToWatch}/**/*.{ts,js,tsx,jsx}`);
      }
      console.log(`\u2713 Watching for file changes in ${path2.relative(process.cwd(), dirToWatch)}`);
    });
    watcher.on("all", (_event, filePath) => {
      if (!/\.(ts|js|tsx|jsx)$/.test(filePath)) {
        return;
      }
      console.info(`File changed: ${path2.relative(dirToWatch, filePath)}`);
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      debounceTimer = setTimeout(() => {
        onChange();
        debounceTimer = null;
      }, 300);
    });
    watcher.on("error", (error) => {
      console.error(`Chokidar watcher error: ${error}`);
    });
    process.on("SIGINT", () => {
      watcher.close().then(() => process.exit(0));
    });
  } catch (error) {
    console.error(`Error setting up file watcher: ${error.message}`);
  }
}

// src/commands/dev/utils/server-manager.ts
import * as path3 from "path";
var serverState = {
  process: null,
  isRunning: false
};
async function getLocalCliPath() {
  const localCliPath = path3.join(
    process.cwd(),
    "node_modules",
    "@elizaos",
    "cli",
    "dist",
    "index.js"
  );
  try {
    const fs14 = await import("fs");
    return fs14.existsSync(localCliPath) ? localCliPath : null;
  } catch {
    return null;
  }
}
function setupEnvironment() {
  const env2 = { ...process.env };
  const localModulesPath = path3.join(process.cwd(), "node_modules");
  if (env2.NODE_PATH) {
    env2.NODE_PATH = `${localModulesPath}${path3.delimiter}${env2.NODE_PATH}`;
  } else {
    env2.NODE_PATH = localModulesPath;
  }
  const localBinPath = path3.join(process.cwd(), "node_modules", ".bin");
  if (env2.PATH) {
    env2.PATH = `${localBinPath}${path3.delimiter}${env2.PATH}`;
  } else {
    env2.PATH = localBinPath;
  }
  env2.FORCE_COLOR = "1";
  if (process.env.ELIZA_TEST_MODE) {
    env2.ELIZA_TEST_MODE = process.env.ELIZA_TEST_MODE;
  }
  return env2;
}
async function startServerProcess(args = []) {
  await stopServerProcess();
  console.info("Starting server...");
  const nodeExecutable = process.execPath;
  const localCliPath = await getLocalCliPath();
  let scriptPath;
  if (localCliPath) {
    console.info("Using local @elizaos/cli installation");
    scriptPath = localCliPath;
  } else {
    scriptPath = process.argv[1];
  }
  const env2 = setupEnvironment();
  const isTestMode = process.env.ELIZA_TEST_MODE === "true";
  const commandArgs = [nodeExecutable, scriptPath, "start", ...args];
  if (isTestMode) {
    console.info(`Executing command: ${commandArgs.join(" ")}`);
  }
  const childProcess = Bun.spawn(commandArgs, {
    stdio: isTestMode ? ["inherit", "pipe", "pipe"] : ["inherit", "inherit", "inherit"],
    env: env2,
    cwd: process.cwd()
  });
  serverState.process = childProcess;
  serverState.isRunning = true;
  if (isTestMode && childProcess.stdout && childProcess.stderr) {
    childProcess.stdout.pipeTo(
      new WritableStream({
        write(chunk) {
          process.stdout.write(chunk);
          return Promise.resolve();
        }
      })
    ).catch((error) => {
      console.error("Error piping stdout:", error);
    });
    childProcess.stderr.pipeTo(
      new WritableStream({
        write(chunk) {
          process.stderr.write(chunk);
          return Promise.resolve();
        }
      })
    ).catch((error) => {
      console.error("Error piping stderr:", error);
    });
  }
  childProcess.exited.then((exitCode) => {
    if (exitCode !== 0) {
      console.warn(`Server process exited with code ${exitCode}`);
    } else {
      console.info("Server process exited normally");
    }
    serverState.process = null;
    serverState.isRunning = false;
  }).catch((error) => {
    console.error(`Server process error: ${error.message}`);
    serverState.process = null;
    serverState.isRunning = false;
  });
}
async function stopServerProcess() {
  if (!serverState.process || !serverState.isRunning) {
    return false;
  }
  console.info("Stopping current server process...");
  try {
    const killed = serverState.process.kill("SIGTERM");
    if (!killed) {
      console.warn("Failed to kill server process, trying force kill...");
      serverState.process.kill("SIGKILL");
    }
    serverState.process = null;
    serverState.isRunning = false;
    await new Promise((resolve2) => setTimeout(resolve2, 500));
    return true;
  } catch (error) {
    console.error(`Error stopping server process: ${error}`);
    serverState.process = null;
    serverState.isRunning = false;
    return false;
  }
}
async function restartServerProcess(args = []) {
  console.info("Restarting server...");
  await startServerProcess(args);
}
function isServerRunning() {
  return serverState.isRunning && serverState.process !== null;
}
function getServerProcess() {
  return serverState.process;
}
var createServerManager = () => ({
  async start(args = []) {
    return startServerProcess(args);
  },
  async stop() {
    return stopServerProcess();
  },
  async restart(args = []) {
    return restartServerProcess(args);
  },
  get process() {
    return getServerProcess();
  },
  isRunning() {
    return isServerRunning();
  }
});
var serverManager = null;
function getServerManager() {
  if (!serverManager) {
    serverManager = createServerManager();
  }
  return serverManager;
}
async function stopServer() {
  return stopServerProcess();
}

// src/commands/dev/actions/dev-server.ts
import { logger } from "@elizaos/core";
async function startDevMode(options) {
  const cwd = process.cwd();
  const context = createDevContext(cwd);
  const serverManager2 = getServerManager();
  const { directoryType } = context;
  const isProject = directoryType.type === "elizaos-project";
  const isPlugin2 = directoryType.type === "elizaos-plugin";
  const isMonorepo = directoryType.type === "elizaos-monorepo";
  if (isProject) {
    console.info("Identified as an ElizaOS project package");
  } else if (isPlugin2) {
    console.info("Identified as an ElizaOS plugin package");
  } else if (isMonorepo) {
    console.info("Identified as an ElizaOS monorepo");
  } else {
    console.warn(
      `Not in a recognized ElizaOS project, plugin, or monorepo directory. Current directory is: ${directoryType.type}. Running in standalone mode.`
    );
  }
  const cliArgs = [];
  let desiredPort;
  if (options.port !== void 0) {
    desiredPort = options.port;
  } else {
    const serverPort = process.env.SERVER_PORT;
    const parsedPort = serverPort ? Number.parseInt(serverPort, 10) : NaN;
    desiredPort = Number.isNaN(parsedPort) ? 3e3 : parsedPort;
  }
  let availablePort;
  try {
    availablePort = await findNextAvailablePort(desiredPort);
    if (availablePort !== desiredPort) {
      logger.warn(`Port ${desiredPort} is in use, using port ${availablePort} instead`);
    }
  } catch (error) {
    logger.error(
      `Failed to find available port starting from ${desiredPort}: ${error instanceof Error ? error.message : String(error)}`
    );
    logger.error("Please specify a different port using --port option");
    throw new Error(`No available ports found starting from ${desiredPort}`);
  }
  cliArgs.push("--port", availablePort.toString());
  if (options.configure) {
    cliArgs.push("--configure");
  }
  if (options.character) {
    if (Array.isArray(options.character)) {
      cliArgs.push("--character", ...options.character);
    } else {
      cliArgs.push("--character", options.character);
    }
  }
  const rebuildAndRestart = async () => {
    try {
      await serverManager2.stop();
      await performRebuild(context);
      console.log("\u2713 Rebuild successful, restarting...");
      await serverManager2.start(cliArgs);
    } catch (error) {
      console.error(
        `Error during rebuild and restart: ${error instanceof Error ? error.message : String(error)}`
      );
      if (!serverManager2.process) {
        console.info("Attempting to restart server regardless of build failure...");
        await serverManager2.start(cliArgs);
      }
    }
  };
  if (isProject || isPlugin2 || isMonorepo) {
    const modeDescription = isMonorepo ? "monorepo" : isProject ? "project" : "plugin";
    console.info(`Running in ${modeDescription} mode`);
    await performInitialBuild(context);
  }
  if (process.env.ELIZA_TEST_MODE === "true") {
    console.info(`[DEV] Starting server with args: ${cliArgs.join(" ")}`);
  }
  await serverManager2.start(cliArgs);
  if (isProject || isPlugin2 || isMonorepo) {
    await watchDirectory(context.watchDirectory, rebuildAndRestart);
    console.log("Dev mode is active! The server will restart when files change.");
    console.log("Press Ctrl+C to exit");
  } else {
    console.log("Server is running in standalone dev mode.");
    console.log("Press Ctrl+C to exit");
  }
}

// src/commands/dev/index.ts
var dev = new Command().name("dev").description(
  "Start the project or plugin in development mode with auto-rebuild, detailed logging, and file change detection"
).option("-c, --configure", "Reconfigure services and AI models (skips using saved configuration)").option("--character [paths...]", "Character file(s) to use - accepts paths or URLs").option("-b, --build", "Build the project before starting").addOption(
  new Option("-p, --port <port>", "Port to listen on (default: 3000)").argParser((value) => {
    const port = Number.parseInt(value, 10);
    if (Number.isNaN(port) || port < 0 || port > 65535) {
      throw new Error("Port must be a number between 0 and 65535");
    }
    return port;
  })
).action(async (options) => {
  try {
    await startDevMode(options);
  } catch (error) {
    handleError(error);
  }
});

// src/commands/env/index.ts
import { Command as Command2 } from "commander";
import colors3 from "yoctocolors";

// src/commands/env/actions/edit.ts
import * as clack from "@clack/prompts";
import { existsSync as existsSync4 } from "fs";
import path5 from "path";

// src/commands/env/utils/file-operations.ts
import { existsSync as existsSync3 } from "fs";
import path4 from "path";
async function getLocalEnvPath() {
  const localEnvPath = path4.join(process.cwd(), ".env");
  return existsSync3(localEnvPath) ? localEnvPath : null;
}
async function parseEnvFile(filePath) {
  const service = createEnvFileService(filePath);
  return service.read();
}
async function writeEnvFile(filePath, envVars) {
  const service = createEnvFileService(filePath);
  await service.write(envVars, {
    preserveComments: true,
    updateProcessEnv: true
  });
}
async function resetEnvFile(filePath) {
  try {
    if (!existsSync3(filePath)) {
      return false;
    }
    const service = createEnvFileService(filePath);
    const envVars = await service.read();
    if (Object.keys(envVars).length === 0) {
      return false;
    }
    const resetVars = Object.keys(envVars).reduce((acc, key) => {
      acc[key] = "";
      return acc;
    }, {});
    await service.write(resetVars, {
      preserveComments: true,
      updateProcessEnv: false
      // Don't update process.env with empty values
    });
    return true;
  } catch (error) {
    console.error(
      `Error resetting environment file: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }
}

// src/commands/env/utils/validation.ts
function maskedValue(value) {
  if (!value) return "";
  if (value.length > 20 && !value.includes(" ")) {
    return `${value.substring(0, 4)}...${value.substring(value.length - 4)}`;
  }
  return value;
}

// src/commands/env/actions/edit.ts
async function editEnvVars(options, fromMainMenu = false) {
  const { yes } = options;
  const localEnvPath = await getLocalEnvPath();
  if (!localEnvPath || !existsSync4(localEnvPath)) {
    const exampleEnvPath = path5.join(process.cwd(), ".env.example");
    const hasExample = existsSync4(exampleEnvPath);
    if (hasExample) {
      console.log("No local .env file found. Create one with:");
      console.log("  cp .env.example .env");
    } else {
      console.log("No local .env file found in the current directory.");
      console.log("Create a .env file to set local environment variables.");
    }
    return fromMainMenu;
  }
  const envVars = await parseEnvFile(localEnvPath);
  if (Object.keys(envVars).length === 0) {
    console.log("Local .env file is empty.");
    const addNew = yes ? false : await clack.confirm({
      message: "Would you like to add a new environment variable?",
      initialValue: true
    });
    if (clack.isCancel(addNew)) {
      clack.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (addNew) {
      await addNewVariable(localEnvPath, envVars, yes);
    }
    return fromMainMenu;
  }
  let exit = false;
  let returnToMain = false;
  if (yes) {
    console.log("\u2705 Environment variables displayed. Use interactive mode without -y to edit.");
    return fromMainMenu;
  }
  while (!exit) {
    const entries = Object.entries(envVars);
    const choices = [
      ...entries.map(([key, value]) => ({
        title: `${key}: ${maskedValue(value)}`,
        value: key
      })),
      { title: "Add new variable", value: "add_new" },
      fromMainMenu ? { title: "Back to main menu", value: "back_to_main" } : { title: "Exit", value: "exit" }
    ];
    const selection = await clack.select({
      message: "Select a variable to edit or an action:",
      options: choices.map((choice) => ({
        value: choice.value,
        label: choice.title
      }))
    });
    if (clack.isCancel(selection)) {
      clack.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!selection) {
      return fromMainMenu;
    }
    if (selection === "exit" || selection === "back_to_main") {
      exit = true;
      returnToMain = selection === "back_to_main";
      continue;
    }
    if (selection === "add_new") {
      await addNewVariable(localEnvPath, envVars, yes);
      continue;
    }
    const action = await clack.select({
      message: `What would you like to do with ${selection}?`,
      options: [
        { label: "Edit", value: "edit" },
        { label: "Delete", value: "delete" },
        { label: "Back", value: "back" }
      ]
    });
    if (clack.isCancel(action)) {
      clack.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!action || action === "back") {
      continue;
    }
    if (action === "edit") {
      const value = await clack.text({
        message: `Enter the new value for ${selection}:`,
        defaultValue: envVars[selection]
      });
      if (clack.isCancel(value)) {
        clack.cancel("Operation cancelled.");
        process.exit(0);
      }
      if (value !== void 0) {
        envVars[selection] = value;
        await writeEnvFile(localEnvPath, envVars);
        console.log(`\u2713 Updated ${selection}`);
      }
    } else if (action === "delete") {
      let confirm9 = true;
      if (!yes) {
        const resp = await clack.confirm({
          message: `Are you sure you want to delete ${selection}?`,
          initialValue: false
        });
        if (clack.isCancel(resp)) {
          clack.cancel("Operation cancelled.");
          process.exit(0);
        }
        confirm9 = resp;
      }
      if (confirm9) {
        delete envVars[selection];
        await writeEnvFile(localEnvPath, envVars);
        console.log(`\u2713 Removed ${selection}`);
      }
    }
  }
  return returnToMain && fromMainMenu;
}
async function addNewVariable(envPath, envVars, yes = false) {
  if (yes) {
    console.log(
      "Auto-confirmation mode enabled - skipping variable addition in edit-local -y mode"
    );
    return;
  }
  const key = await clack.text({
    message: "Enter the variable name:",
    validate: (value2) => value2.trim() !== "" ? void 0 : "Variable name cannot be empty"
  });
  if (clack.isCancel(key)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  if (!key) return;
  const value = await clack.text({
    message: `Enter the value for ${key}:`,
    defaultValue: ""
  });
  if (clack.isCancel(value)) {
    clack.cancel("Operation cancelled.");
    process.exit(0);
  }
  if (value !== void 0) {
    envVars[key] = value;
    await writeEnvFile(envPath, envVars);
    console.log(`\u2713 Added ${key}`);
  }
}

// src/commands/env/actions/interactive.ts
import * as clack3 from "@clack/prompts";

// src/commands/env/actions/list.ts
import { existsSync as existsSync5 } from "fs";
import path6 from "path";
import colors from "yoctocolors";
async function listEnvVars() {
  const envInfo = await UserEnvironment.getInstanceInfo();
  console.info(colors.bold("\nSystem Information:"));
  console.info(`  Platform: ${colors.cyan(envInfo.os.platform)} (${envInfo.os.release})`);
  console.info(`  Architecture: ${colors.cyan(envInfo.os.arch)}`);
  console.info(`  CLI Version: ${colors.cyan(envInfo.cli.version)}`);
  console.info(
    `  Package Manager: ${colors.cyan(envInfo.packageManager.name)}${envInfo.packageManager.version ? ` v${envInfo.packageManager.version}` : ""}`
  );
  console.info(colors.bold("\nLocal Environment Variables:"));
  const localEnvFilePath = await getLocalEnvPath();
  console.info(`Path: ${localEnvFilePath ?? path6.join(process.cwd(), ".env")}`);
  if (!localEnvFilePath || !existsSync5(localEnvFilePath)) {
    console.info(colors.yellow("  No local .env file found"));
    const exampleEnvPath = path6.join(process.cwd(), ".env.example");
    if (existsSync5(exampleEnvPath)) {
      console.info(colors.red("  [X] Missing .env file. Create one with:"));
      console.info(`     ${colors.bold(colors.green("cp .env.example .env"))}`);
    } else {
      console.info(
        colors.red(
          "  [X] Missing .env file. Create one in your project directory to set local environment variables."
        )
      );
    }
  } else {
    const localEnvVars = await parseEnvFile(localEnvFilePath);
    if (Object.keys(localEnvVars).length === 0) {
      console.info("  No local environment variables set");
    } else {
      for (const [key, value] of Object.entries(localEnvVars)) {
        console.info(`  ${colors.green(key)}: ${maskedValue(value)}`);
      }
    }
  }
  console.info("\n");
  console.info(
    colors.cyan(
      "You can also edit environment variables in the web UI: http://localhost:3000/settings"
    )
  );
}
async function handleListCommand(options) {
  if (options.system) {
    const envInfo = await UserEnvironment.getInstanceInfo();
    console.info(colors.bold("\nSystem Information:"));
    console.info(`  Platform: ${colors.cyan(envInfo.os.platform)} (${envInfo.os.release})`);
    console.info(`  Architecture: ${colors.cyan(envInfo.os.arch)}`);
    console.info(`  CLI Version: ${colors.cyan(envInfo.cli.version)}`);
    console.info(
      `  Package Manager: ${colors.cyan(envInfo.packageManager.name)}${envInfo.packageManager.version ? ` v${envInfo.packageManager.version}` : ""}`
    );
  } else if (options.local) {
    console.info(colors.bold("\nLocal Environment Variables:"));
    const localEnvPath = await getLocalEnvPath();
    if (!localEnvPath || !existsSync5(localEnvPath)) {
      console.info("  No local .env file found in the current directory");
      return;
    }
    const localEnvVars = await parseEnvFile(localEnvPath);
    if (Object.keys(localEnvVars).length === 0) {
      console.info("  No local environment variables set");
    } else {
      for (const [key, value] of Object.entries(localEnvVars)) {
        console.info(`  ${colors.green(key)}: ${maskedValue(value)}`);
      }
    }
  } else {
    await listEnvVars();
  }
}

// src/commands/env/actions/reset.ts
import * as clack2 from "@clack/prompts";
import { existsSync as existsSync7 } from "fs";
import path7 from "path";
import colors2 from "yoctocolors";

// src/commands/env/utils/directory-operations.ts
import { existsSync as existsSync6 } from "fs";
import { rimraf } from "rimraf";
async function safeDeleteDirectory(dir, actions, label) {
  if (!existsSync6(dir)) {
    actions.skipped.push(`${label} (not found)`);
    return false;
  }
  try {
    await rimraf(dir);
    if (!existsSync6(dir)) {
      actions.deleted.push(label);
      return true;
    } else {
      actions.warning.push(`Failed to delete ${label.toLowerCase()}`);
      return false;
    }
  } catch (error) {
    actions.warning.push(`Failed to delete ${label.toLowerCase()}`);
    return false;
  }
}

// src/commands/env/actions/reset.ts
async function resolvePgliteDir2() {
  return path7.join(process.cwd(), ".eliza", "db");
}
async function resetEnv(options) {
  const { yes } = options;
  const elizaDir = path7.join(process.cwd(), ".eliza");
  const cacheDir = path7.join(elizaDir, "cache");
  const localEnvPath = await getLocalEnvPath() ?? path7.join(process.cwd(), ".env");
  const localDbDir = await resolvePgliteDir2();
  const resetItems = [
    {
      title: "Local environment variables",
      value: "localEnv",
      description: existsSync7(localEnvPath) ? "Reset values in local .env file" : "Local .env file not found, nothing to reset",
      selected: existsSync7(localEnvPath)
    },
    {
      title: "Cache folder",
      value: "cache",
      description: existsSync7(cacheDir) ? "Delete the cache folder" : "Cache folder not found, nothing to delete",
      selected: existsSync7(cacheDir)
    },
    {
      title: "Local database files",
      value: "localDb",
      description: existsSync7(localDbDir) ? "Delete local database files" : "Local database folder not found, nothing to delete",
      selected: existsSync7(localDbDir)
    }
  ];
  const validResetItems = resetItems.filter(
    (item) => item.value === "localEnv" && existsSync7(localEnvPath) || item.value === "cache" && existsSync7(cacheDir) || item.value === "localDb" && existsSync7(localDbDir)
  );
  let selectedValues = [];
  if (yes) {
    selectedValues = validResetItems.map((item) => item.value);
    if (selectedValues.length > 0) {
      console.info(colors2.bold("The following items will be reset:"));
      for (const value of selectedValues) {
        const item = resetItems.find((item2) => item2.value === value);
        console.info(`  \u2022 ${item?.title || value}`);
      }
    } else {
      console.info("No valid items found to reset.");
      return;
    }
  } else {
    const selections = await clack2.multiselect({
      message: colors2.cyan(colors2.bold("Select items to reset:")),
      options: resetItems.map((item) => ({ value: item.value, label: item.title })),
      required: true
    });
    if (clack2.isCancel(selections)) {
      clack2.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!selections || selections.length === 0) {
      console.log("No items selected. Reset cancelled.");
      return;
    }
    selectedValues = selections;
    console.log("\nYou selected:");
    for (const value of selectedValues) {
      const item = resetItems.find((item2) => item2.value === value);
      console.log(`  \u2022 ${item?.title || value}`);
    }
    const confirm9 = await clack2.confirm({
      message: "Are you sure you want to reset the selected items?",
      initialValue: false
    });
    if (clack2.isCancel(confirm9)) {
      clack2.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!confirm9) {
      console.log("Reset cancelled.");
      return;
    }
  }
  const actions = {
    reset: [],
    deleted: [],
    skipped: [],
    warning: []
  };
  for (const target of selectedValues) {
    switch (target) {
      case "localEnv":
        if (await resetEnvFile(localEnvPath)) {
          actions.reset.push("Local environment variables");
        } else {
          actions.skipped.push("Local environment variables (no file or empty)");
        }
        break;
      case "cache":
        await safeDeleteDirectory(cacheDir, actions, "Cache folder");
        break;
      case "localDb":
        await safeDeleteDirectory(localDbDir, actions, "Local database folder");
        break;
    }
  }
  console.log(colors2.bold("\nReset Summary:"));
  if (actions.reset.length > 0) {
    console.log(colors2.green("  Values Cleared:"));
    actions.reset.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  if (actions.deleted.length > 0) {
    console.log(colors2.green("  Deleted:"));
    actions.deleted.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  if (actions.skipped.length > 0) {
    console.log(colors2.yellow("  Skipped:"));
    actions.skipped.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  if (actions.warning.length > 0) {
    console.log(colors2.red("  Warnings:"));
    actions.warning.forEach((item) => console.log(`    \u2022 ${item}`));
  }
  console.log(colors2.bold("\nEnvironment reset complete"));
}

// src/commands/env/actions/interactive.ts
async function showMainMenu(options) {
  const { yes } = options;
  let exit = false;
  while (!exit) {
    const action = await clack3.select({
      message: "Select an action:",
      options: [
        { label: "List environment variables", value: "list" },
        { label: "Edit local environment variables", value: "edit_local" },
        { label: "Reset environment variables", value: "reset" },
        { label: "Exit", value: "exit" }
      ]
    });
    if (clack3.isCancel(action)) {
      clack3.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!action || action === "exit") {
      exit = true;
      continue;
    }
    switch (action) {
      case "list":
        await listEnvVars();
        break;
      case "edit_local": {
        const returnToMainFromLocal = await editEnvVars({ yes }, true);
        exit = !returnToMainFromLocal;
        break;
      }
      case "reset":
        await resetEnv({ yes });
        break;
    }
  }
}

// src/commands/env/index.ts
var env = new Command2().name("env").description("Manage environment variables and secrets");
env.command("list").description("List all environment variables").option("--system", "List only system information").option("--local", "List only local environment variables").action(async (options) => {
  try {
    await handleListCommand(options);
  } catch (error) {
    handleError(error);
  }
});
env.command("edit-local").description("Edit local environment variables").option("-y, --yes", "Automatically confirm prompts").action(async (options) => {
  try {
    await editEnvVars(options);
  } catch (error) {
    handleError(error);
  }
});
env.command("reset").description(
  "Reset environment variables and clean up database/cache files (interactive selection)"
).option("-y, --yes", "Automatically reset using default selections").action(async (options) => {
  try {
    await resetEnv(options);
  } catch (error) {
    handleError(error);
  }
});
env.command("interactive").description("Interactive environment variable management").option("-y, --yes", "Automatically confirm prompts").action(async (options) => {
  try {
    await showMainMenu(options);
  } catch (error) {
    handleError(error);
  }
});
env.action(() => {
  console.log(colors3.bold("\nEliza Environment Variable Manager"));
  console.log("\nAvailable commands:");
  console.log("  list                  List all environment variables");
  console.log("  edit-local            Edit local environment variables");
  console.log(
    "  reset                 Reset environment variables and clean up database/cache files (interactive selection)"
  );
  console.log("  interactive           Start interactive environment variable manager");
  console.log("\nYou can also edit environment variables in the web UI:");
  console.log("  http://localhost:3000/settings");
});

// src/commands/plugins/index.ts
import { Command as Command3 } from "commander";

// src/commands/plugins/actions/install.ts
import { logger as logger4 } from "@elizaos/core";

// src/commands/plugins/utils/naming.ts
var findPluginPackageName = (pluginInput, allDependencies) => {
  let normalizedBase = pluginInput.startsWith("@") ? pluginInput.split("/")[1] || pluginInput : pluginInput;
  normalizedBase = normalizedBase.replace(/^plugin-/, "");
  const possibleNames = [
    pluginInput,
    // Check the raw input first
    `@elizaos/plugin-${normalizedBase}`,
    // Prioritize @elizaos/ scope
    `@elizaos/${normalizedBase}`,
    // Might be needed if input was 'plugin-abc' -> base 'abc' -> check '@elizaos/abc'
    `@elizaos/plugin-${normalizedBase}`,
    // Check alternative scope
    `plugin-${normalizedBase}`,
    `@elizaos/${normalizedBase}`
  ];
  for (const name of possibleNames) {
    if (allDependencies[name]) {
      return name;
    }
  }
  return null;
};
var extractPackageName = (pluginInput) => {
  const githubUrlRegex = /^https?:\/\/github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+?)(?:\.git)?(?:#([a-zA-Z0-9_.-]+))?$/;
  const githubShortRegex = /^(?:github:)?([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:#([a-zA-Z0-9_.-]+))?$/;
  const githubUrlMatch = pluginInput.match(githubUrlRegex);
  if (githubUrlMatch) {
    const [, owner, repo] = githubUrlMatch;
    return `@${owner}/${repo}`;
  }
  const githubShortMatch = pluginInput.match(githubShortRegex);
  if (githubShortMatch) {
    const [, owner, repo] = githubShortMatch;
    return `@${owner}/${repo}`;
  }
  return pluginInput;
};

// src/commands/plugins/utils/env-vars.ts
import { logger as logger2 } from "@elizaos/core";
import { existsSync as existsSync8, readFileSync, readdirSync as readdirSync2 } from "fs";
import path8 from "path";
import * as clack4 from "@clack/prompts";
var extractPluginEnvRequirements = async (packageName, cwd) => {
  try {
    const possiblePaths = [
      // Direct path
      path8.join(cwd, "node_modules", packageName, "package.json"),
      // Scoped package path (e.g., @elizaos/plugin-discord)
      path8.join(cwd, "node_modules", packageName.replace("/", path8.sep), "package.json")
    ];
    if (!packageName.startsWith("@elizaos/")) {
      possiblePaths.push(
        path8.join(cwd, "node_modules", "@elizaos", packageName, "package.json"),
        path8.join(cwd, "node_modules", "@elizaos", `plugin-${packageName}`, "package.json")
      );
    }
    let currentDir = cwd;
    for (let i = 0; i < 5; i++) {
      const parentNodeModules = path8.join(currentDir, "node_modules");
      if (existsSync8(parentNodeModules)) {
        possiblePaths.push(
          path8.join(parentNodeModules, packageName, "package.json"),
          path8.join(parentNodeModules, packageName.replace("/", path8.sep), "package.json")
        );
      }
      const parentDir = path8.dirname(currentDir);
      if (parentDir === currentDir) break;
      currentDir = parentDir;
    }
    let packageJsonPath = null;
    for (const possiblePath of possiblePaths) {
      if (existsSync8(possiblePath)) {
        packageJsonPath = possiblePath;
        logger2.debug(`Found plugin package.json at: ${packageJsonPath}`);
        break;
      }
    }
    if (!packageJsonPath) {
      const nodeModulesPath = path8.join(cwd, "node_modules");
      if (existsSync8(nodeModulesPath)) {
        const packages = readdirSync2(nodeModulesPath);
        for (const pkg of packages) {
          if (pkg.includes(packageName.replace("@elizaos/", "").replace("plugin-", ""))) {
            const pkgJsonPath = path8.join(nodeModulesPath, pkg, "package.json");
            if (existsSync8(pkgJsonPath)) {
              packageJsonPath = pkgJsonPath;
              logger2.debug(`Found matching plugin package.json at: ${packageJsonPath}`);
              break;
            }
          }
        }
      }
    }
    if (!packageJsonPath) {
      logger2.debug(`Plugin package.json not found for: ${packageName}`);
      logger2.debug(`Searched paths: ${possiblePaths.join(", ")}`);
      return {};
    }
    const packageJsonContent = readFileSync(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    const agentConfig = packageJson.agentConfig;
    if (!agentConfig || !agentConfig.pluginParameters) {
      logger2.debug(`No agentConfig.pluginParameters found in ${packageName} at ${packageJsonPath}`);
      return {};
    }
    logger2.debug(
      `Found environment variables for ${packageName}: ${Object.keys(agentConfig.pluginParameters).join(", ")}`
    );
    return agentConfig.pluginParameters;
  } catch (error) {
    logger2.debug(
      `Error reading plugin package.json for ${packageName}: ${error instanceof Error ? error.message : String(error)}`
    );
    return {};
  }
};
var readEnvFile = async (cwd) => {
  const envPath = path8.join(cwd, ".env");
  const envService = createEnvFileService(envPath);
  return envService.read();
};
var extractDefaultFromDescription = (description) => {
  const patterns = [
    /\(e\.g\.,\s*([^)]+)\)/i,
    // (e.g., value)
    /e\.g\.,?\s*([^.,\s]+)/i,
    // e.g., value or e.g. value
    /example:\s*([^.,\s]+)/i,
    // example: value
    /default:\s*([^.,\s]+)/i
    // default: value
  ];
  for (const pattern of patterns) {
    const match = description.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }
  return void 0;
};
var promptForEnvVar = async (varName, config2) => {
  const {
    type = "string",
    description = "No description available",
    default: explicitDefault,
    sensitive = false,
    required = true
    // Default to true for backwards compatibility
  } = config2;
  const defaultValue = explicitDefault || extractDefaultFromDescription(description);
  const isSecret = sensitive !== void 0 ? sensitive : varName.toLowerCase().includes("key") || varName.toLowerCase().includes("token") || varName.toLowerCase().includes("secret") || varName.toLowerCase().includes("password");
  if (description && description !== "No description available") {
    clack4.note(`${description}`, `${varName} Info`);
  }
  if (type === "boolean") {
    const defaultBool = defaultValue === "true" || String(explicitDefault).toLowerCase() === "true";
    const response2 = await clack4.confirm({
      message: required ? `Enable ${varName}?` : `Enable ${varName}? (optional)`,
      initialValue: defaultBool
    });
    if (clack4.isCancel(response2)) {
      clack4.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!required && response2 === void 0) {
      return "";
    }
    return String(response2);
  }
  if (type === "number") {
    const message2 = defaultValue ? `Enter ${varName} (default: ${String(defaultValue)})` : required ? `Enter ${varName}` : `Enter ${varName} (press Enter to skip)`;
    const promptConfig2 = {
      message: message2,
      placeholder: required ? String(defaultValue || "Enter a number") : String(defaultValue || "Press Enter to skip"),
      initialValue: defaultValue ? String(defaultValue) : void 0,
      validate: (input) => {
        if ((!input || input.trim() === "") && !required) {
          return void 0;
        }
        if ((!input || input.trim() === "") && required && !defaultValue) {
          return "This field cannot be empty. Press Ctrl+C to cancel.";
        }
        const trimmed = input.trim();
        if (trimmed && isNaN(Number(trimmed))) {
          return "Please enter a valid number";
        }
        return void 0;
      }
    };
    const response2 = await clack4.text(promptConfig2);
    if (clack4.isCancel(response2)) {
      clack4.cancel("Operation cancelled.");
      process.exit(0);
    }
    const finalValue2 = response2 && response2.trim() || defaultValue || "";
    return finalValue2.trim();
  }
  if (type === "array") {
    const message2 = defaultValue ? `Enter ${varName} (comma-separated, default: ${String(defaultValue)})` : required ? `Enter ${varName} (comma-separated values)` : `Enter ${varName} (comma-separated values, press Enter to skip)`;
    const promptConfig2 = {
      message: message2,
      placeholder: required ? String(defaultValue || "value1,value2,value3") : String(defaultValue || "Press Enter to skip"),
      initialValue: defaultValue ? String(defaultValue) : void 0,
      validate: (input) => {
        if ((!input || input.trim() === "") && !required) {
          return void 0;
        }
        if ((!input || input.trim() === "") && required && !defaultValue) {
          return "This field cannot be empty. Press Ctrl+C to cancel.";
        }
        return void 0;
      }
    };
    const response2 = await clack4.text(promptConfig2);
    if (clack4.isCancel(response2)) {
      clack4.cancel("Operation cancelled.");
      process.exit(0);
    }
    const finalValue2 = response2 && response2.trim() || defaultValue || "";
    if (finalValue2) {
      return finalValue2.split(",").map((v) => v.trim()).filter((v) => v).join(",");
    }
    return finalValue2;
  }
  if (type === "json") {
    clack4.log.info("Enter a JSON object. For multi-line input, use the editor.");
    const message2 = defaultValue ? `Enter ${varName} JSON (default: ${String(defaultValue)})` : required ? `Enter ${varName} JSON` : `Enter ${varName} JSON (press Enter to skip)`;
    const promptConfig2 = {
      message: message2,
      placeholder: required ? String(defaultValue || '{"key": "value"}') : String(defaultValue || "Press Enter to skip"),
      initialValue: defaultValue ? String(defaultValue) : void 0,
      validate: (input) => {
        if ((!input || input.trim() === "") && !required) {
          return void 0;
        }
        if ((!input || input.trim() === "") && required && !defaultValue) {
          return "This field cannot be empty. Press Ctrl+C to cancel.";
        }
        if (input && input.trim()) {
          try {
            JSON.parse(input.trim());
          } catch (error) {
            return "Please enter valid JSON format";
          }
        }
        return void 0;
      }
    };
    const response2 = await clack4.text(promptConfig2);
    if (clack4.isCancel(response2)) {
      clack4.cancel("Operation cancelled.");
      process.exit(0);
    }
    const finalValue2 = response2 && response2.trim() || defaultValue || "";
    if (finalValue2) {
      try {
        const parsed = JSON.parse(finalValue2);
        return JSON.stringify(parsed);
      } catch {
        return finalValue2;
      }
    }
    return finalValue2;
  }
  const message = defaultValue ? `Enter ${varName} (default: ${String(defaultValue)})` : required ? `Enter ${varName}` : `Enter ${varName} (press Enter to skip)`;
  const placeholder = isSecret ? "Your secret key/token..." : required ? String(defaultValue || "Required value") : String(defaultValue || "Press Enter to skip");
  const promptFn = isSecret ? clack4.password : clack4.text;
  const promptConfig = {
    message,
    placeholder,
    validate: (input) => {
      if ((!input || input.trim() === "") && required && !defaultValue) {
        return "This field cannot be empty. Press Ctrl+C to cancel.";
      }
      if ((!input || input.trim() === "") && !required) {
        return void 0;
      }
      if (varName.includes("URL") || varName.includes("ENDPOINT")) {
        if (input && input.trim()) {
          try {
            new URL(input.trim());
          } catch {
            return "Please enter a valid URL (e.g., https://api.example.com)";
          }
        }
      }
      if (varName.includes("API_KEY") && input.trim().length > 0 && input.trim().length < 5) {
        return "API key seems too short. Please verify you entered the complete key.";
      }
      return void 0;
    }
  };
  if (defaultValue && !isSecret) {
    promptConfig.initialValue = String(defaultValue);
  }
  const response = await promptFn(promptConfig);
  if (clack4.isCancel(response)) {
    clack4.cancel("Operation cancelled.");
    process.exit(0);
  }
  const finalValue = response && response.trim() || defaultValue || "";
  return finalValue.trim();
};
var updateEnvFile = async (cwd, varName, value) => {
  const envPath = path8.join(cwd, ".env");
  const envService = createEnvFileService(envPath);
  await envService.update(varName, value, {
    preserveComments: true,
    updateProcessEnv: true
  });
};
var promptForPluginEnvVars = async (packageName, cwd) => {
  let envRequirements = await extractPluginEnvRequirements(packageName, cwd);
  if (Object.keys(envRequirements).length === 0 && !packageName.startsWith("@elizaos/")) {
    const elizaosPackageName = `@elizaos/${packageName.replace("plugin-", "")}`;
    envRequirements = await extractPluginEnvRequirements(elizaosPackageName, cwd);
    if (Object.keys(envRequirements).length === 0) {
      const elizaosPluginPackageName = `@elizaos/plugin-${packageName.replace("plugin-", "")}`;
      envRequirements = await extractPluginEnvRequirements(elizaosPluginPackageName, cwd);
    }
  }
  if (Object.keys(envRequirements).length === 0) {
    const nodeModulesPath = path8.join(cwd, "node_modules");
    const possiblePackages = [
      packageName,
      `@elizaos/${packageName.replace("plugin-", "")}`,
      `@elizaos/plugin-${packageName.replace("plugin-", "")}`
    ];
    let packageFound = false;
    for (const pkg of possiblePackages) {
      const pkgPath = path8.join(nodeModulesPath, ...pkg.split("/"));
      if (existsSync8(path8.join(pkgPath, "package.json"))) {
        packageFound = true;
        break;
      }
    }
    if (packageFound) {
      logger2.debug(`Package ${packageName} found but has no environment variables defined`);
      clack4.log.success(`No environment variables required for ${packageName}`);
    } else {
      logger2.debug(`Package ${packageName} not found in node_modules`);
      clack4.log.warn(
        `Could not find ${packageName} in node_modules. Environment variables may need to be configured manually.`
      );
    }
    return;
  }
  await new Promise((resolve2) => setTimeout(resolve2, 100));
  clack4.intro(`Setting up ${packageName} Plugin`);
  const envVars = await readEnvFile(cwd);
  const existingVars = envVars;
  const missingVars = [];
  const existingConfigured = [];
  Object.entries(envRequirements).forEach(([varName, config2]) => {
    if (existingVars[varName] && existingVars[varName] !== "") {
      existingConfigured.push(varName);
    } else {
      missingVars.push([varName, config2]);
    }
  });
  if (existingConfigured.length > 0) {
    clack4.note(existingConfigured.map((name) => `${name}`).join("\n"), "Already Configured");
  }
  if (missingVars.length === 0) {
    clack4.outro("All environment variables are already configured!");
    return;
  }
  const totalVars = Object.keys(envRequirements).length;
  const requiredVars = missingVars.filter(([, config2]) => config2.required !== false);
  const optionalVars = missingVars.filter(([, config2]) => config2.required === false);
  let configMessage = `We need to configure ${missingVars.length} of ${totalVars} environment variables.

`;
  if (requiredVars.length > 0) {
    configMessage += `Required (${requiredVars.length}):
${requiredVars.map(([name]) => `  - ${name}`).join("\n")}

`;
  }
  if (optionalVars.length > 0) {
    configMessage += `Optional (${optionalVars.length}):
${optionalVars.map(([name]) => `  - ${name}`).join("\n")}

`;
  }
  configMessage += `Tip: Press Ctrl+C at any time to cancel.`;
  clack4.note(configMessage, "Configuration Needed");
  const spinner2 = clack4.spinner();
  let configuredCount = existingConfigured.length;
  let newlyConfigured = 0;
  const sessionConfigured = /* @__PURE__ */ new Set();
  for (let i = 0; i < missingVars.length; i++) {
    const [varName, config2] = missingVars[i];
    if (i > 0) {
      console.log("");
    }
    const isRequired = config2.required !== false;
    const statusText = isRequired ? "Required" : "Optional";
    clack4.log.info(`[${i + 1}/${missingVars.length}] ${varName} (${statusText})`);
    try {
      const value = await promptForEnvVar(varName, config2);
      if (value) {
        spinner2.start(`Saving ${varName} to .env file...`);
        await updateEnvFile(cwd, varName, value);
        spinner2.stop(`${varName} configured successfully`);
        newlyConfigured++;
        configuredCount++;
        sessionConfigured.add(varName);
      } else {
        const isRequired2 = config2.required !== false;
        if (isRequired2) {
          clack4.log.warn(`Skipped required variable ${varName} - plugin may not work correctly`);
        } else {
          clack4.log.info(`Skipped optional variable ${varName}`);
        }
      }
    } catch (error) {
      spinner2.stop();
      clack4.log.error(
        `Failed to configure ${varName}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  const requiredConfigured = Object.entries(envRequirements).filter(([, config2]) => config2.required !== false).filter(
    ([name]) => existingVars[name] && existingVars[name] !== "" || sessionConfigured.has(name)
  ).length;
  const totalRequired = Object.entries(envRequirements).filter(
    ([, config2]) => config2.required !== false
  ).length;
  if (configuredCount === totalVars) {
    clack4.outro(
      `Perfect! All ${totalVars} environment variables are configured.

Your ${packageName} plugin is ready to use!

Next steps:
- Restart your application to load the new environment variables
- Check your .env file if you need to modify any values later`
    );
  } else if (newlyConfigured > 0) {
    let message = `Successfully configured ${newlyConfigured} new environment variables!

`;
    message += `Status: ${configuredCount}/${totalVars} total variables configured
`;
    if (requiredConfigured === totalRequired) {
      message += `All required variables are set - your plugin should work!

`;
    } else {
      message += `${totalRequired - requiredConfigured} required variables still missing

`;
    }
    message += `Next steps:
`;
    message += `- Restart your application to load new environment variables
`;
    if (totalVars - configuredCount > 0) {
      message += `- Configure remaining ${totalVars - configuredCount} variables in your .env file if needed
`;
    }
    message += `- Check the plugin documentation for additional setup steps`;
    clack4.outro(message);
  } else {
    clack4.outro(
      `No new variables were configured.

To set up this plugin, add these variables to your .env file:

` + missingVars.map(([name, config2]) => {
        const required = config2.required !== false ? " (Required)" : " (Optional)";
        return `${name}=your_value_here${required}`;
      }).join("\n") + `

Restart your application after adding the variables.`
    );
  }
};

// src/commands/plugins/utils/directory.ts
import { logger as logger3 } from "@elizaos/core";
import { readFileSync as readFileSync2 } from "fs";
import path9 from "path";
var getDependenciesFromDirectory = (cwd) => {
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo.hasPackageJson) {
    return null;
  }
  try {
    const packageJsonPath = path9.join(cwd, "package.json");
    const packageJsonContent = readFileSync2(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    const dependencies = packageJson.dependencies || {};
    const devDependencies = packageJson.devDependencies || {};
    return { ...dependencies, ...devDependencies };
  } catch (error) {
    if (error instanceof SyntaxError) {
      logger3.warn(`Could not parse package.json: ${error.message}`);
    } else {
      logger3.warn(
        `Error reading package.json: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    return null;
  }
};

// src/commands/plugins/actions/install.ts
import * as clack5 from "@clack/prompts";
import colors4 from "yoctocolors";
function showInstallationSuccess(pluginName) {
  const message = `${colors4.green("\u2713")} Plugin installed successfully!

${colors4.bold("Next steps:")}
1. Add ${colors4.cyan(`"${pluginName}"`)} to your character file's plugins array:

   ${colors4.gray("{")}${colors4.dim("\n")}     ${colors4.green('"name"')}: ${colors4.yellow('"YourAgent"')},${colors4.dim("\n")}     ${colors4.green('"plugins"')}: [${colors4.cyan(`"${pluginName}"`)}],${colors4.dim("\n")}     ${colors4.gray("...")}${colors4.dim("\n")}   ${colors4.gray("}")}

2. Restart your application to load the plugin
3. Configure any required environment variables
4. Check the plugin documentation for additional setup`;
  clack5.outro(message);
}
async function installPluginFromGitHub(plugin, cwd, opts) {
  const githubRegex = /^(?:github:)?([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:#([a-zA-Z0-9_.-]+))?$/;
  const githubMatch = plugin.match(githubRegex);
  if (!githubMatch) {
    throw new Error("Invalid GitHub repository format");
  }
  const [, owner, repo, ref] = githubMatch;
  const githubSpecifier = `github:${owner}/${repo}${ref ? `#${ref}` : ""}`;
  const pluginNameForPostInstall = repo;
  const success = await installPlugin(githubSpecifier, cwd, void 0, opts.skipVerification);
  if (success) {
    logger4.info(`Successfully installed ${pluginNameForPostInstall} from ${githubSpecifier}.`);
    const packageName = extractPackageName(plugin);
    if (!opts.skipEnvPrompt) {
      await new Promise((resolve2) => setTimeout(resolve2, 500));
      console.log(`
\u{1F527} Checking environment variables for ${packageName}...`);
      try {
        await promptForPluginEnvVars(packageName, cwd);
      } catch (error) {
        logger4.warn(
          `Warning: Could not prompt for environment variables: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    } else {
      console.log(`
\u23ED\uFE0F  Skipping environment variable prompts due to --skip-env-prompt flag`);
    }
    showInstallationSuccess(packageName);
    process.exit(0);
  } else {
    logger4.error(`Failed to install plugin from ${githubSpecifier}.`);
    process.exit(1);
  }
}
async function installPluginFromRegistry(plugin, cwd, opts) {
  const cachedRegistry = await fetchPluginRegistry();
  if (!cachedRegistry || !cachedRegistry.registry) {
    logger4.error('Plugin registry cache not found. Please run "elizaos plugins update" first.');
    process.exit(1);
  }
  const possibleNames = normalizePluginName(plugin);
  const pluginKey = possibleNames.find((name) => cachedRegistry.registry[name]);
  const targetName = pluginKey || plugin;
  const registryInstallResult = await installPlugin(
    targetName,
    cwd,
    opts.tag,
    opts.skipVerification
  );
  if (registryInstallResult) {
    console.log(`Successfully installed ${targetName}`);
    const updatedDependencies = getDependenciesFromDirectory(cwd);
    const actualPackageName = findPluginPackageName(targetName, updatedDependencies || {}) || targetName;
    if (!opts.skipEnvPrompt) {
      await new Promise((resolve2) => setTimeout(resolve2, 500));
      console.log(`
\u{1F527} Checking environment variables for ${actualPackageName}...`);
      try {
        await promptForPluginEnvVars(actualPackageName, cwd);
      } catch (error) {
        logger4.warn(
          `Warning: Could not prompt for environment variables: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    } else {
      console.log(`
\u23ED\uFE0F  Skipping environment variable prompts due to --skip-env-prompt flag`);
    }
    showInstallationSuccess(actualPackageName);
    process.exit(0);
  }
  console.error(`Failed to install ${targetName} from registry.`);
  process.exit(1);
}
async function addPlugin(pluginArg, opts) {
  if (!pluginArg || !pluginArg.trim()) {
    logger4.error("Plugin name cannot be empty or whitespace-only.");
    logger4.info(
      'Please provide a valid plugin name (e.g., "openai", "plugin-anthropic", "@elizaos/plugin-sql")'
    );
    process.exit(1);
  }
  const cwd = process.cwd();
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo || !directoryInfo.hasPackageJson) {
    logger4.error(
      `Command must be run inside an ElizaOS project directory. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
    );
    process.exit(1);
  }
  const allDependencies = getDependenciesFromDirectory(cwd);
  if (!allDependencies) {
    logger4.error("Could not read dependencies from package.json");
    process.exit(1);
  }
  let plugin = pluginArg;
  const httpsGitHubUrlRegex = (
    // eslint-disable-next-line no-useless-escape
    /^https?:\/\/github\.com\/([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+?)(?:\.git)?(?:(?:#|\/tree\/|\/commit\/)([a-zA-Z0-9_.-]+))?\/?$/
  );
  const httpsMatch = plugin.match(httpsGitHubUrlRegex);
  if (httpsMatch) {
    const [, owner, repo, ref] = httpsMatch;
    plugin = `github:${owner}/${repo}${ref ? `#${ref}` : ""}`;
  }
  const installedPluginName = findPluginPackageName(plugin, allDependencies);
  if (installedPluginName) {
    logger4.info(`Plugin "${installedPluginName}" is already added to this project.`);
    process.exit(0);
  }
  const githubRegex = /^(?:github:)?([a-zA-Z0-9_-]+)\/([a-zA-Z0-9_.-]+)(?:#([a-zA-Z0-9_.-]+))?$/;
  if (githubRegex.test(plugin)) {
    await installPluginFromGitHub(plugin, cwd, opts);
  } else {
    await installPluginFromRegistry(plugin, cwd, opts);
  }
}

// src/commands/plugins/actions/remove.ts
import { logger as logger5 } from "@elizaos/core";
import { existsSync as existsSync9, rmSync } from "fs";
import path10 from "path";
async function removePlugin(plugin) {
  const cwd = process.cwd();
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo || !directoryInfo.hasPackageJson) {
    console.error(
      `Could not read or parse package.json. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
    );
    process.exit(1);
  }
  const allDependencies = getDependenciesFromDirectory(cwd);
  if (!allDependencies) {
    console.error(
      "Could not read dependencies from package.json. Cannot determine which package to remove."
    );
    process.exit(1);
  }
  const packageNameToRemove = findPluginPackageName(plugin, allDependencies);
  if (!packageNameToRemove) {
    logger5.warn(`Plugin matching "${plugin}" not found in project dependencies.`);
    console.info("\nCheck installed plugins using: elizaos plugins installed-plugins");
    process.exit(0);
  }
  console.info(`Removing ${packageNameToRemove}...`);
  try {
    await bunExecInherit("bun", ["remove", packageNameToRemove], {
      cwd
    });
  } catch (execError) {
    logger5.error(
      `Failed to run 'bun remove ${packageNameToRemove}': ${execError instanceof Error ? execError.message : String(execError)}`
    );
    if (execError && typeof execError === "object" && "stderr" in execError && typeof execError.stderr === "string" && execError.stderr.includes("not found")) {
      logger5.info(
        `'bun remove' indicated package was not found. Continuing with directory removal attempt.`
      );
    } else {
      handleError(execError);
      process.exit(1);
    }
  }
  let baseName = packageNameToRemove;
  if (packageNameToRemove.includes("/")) {
    const parts = packageNameToRemove.split("/");
    baseName = parts[parts.length - 1];
  }
  baseName = baseName.replace(/^plugin-/, "");
  const dirNameToRemove = `plugin-${baseName}`;
  const pluginDir = path10.join(cwd, dirNameToRemove);
  if (existsSync9(pluginDir)) {
    try {
      rmSync(pluginDir, { recursive: true, force: true });
    } catch (rmError) {
      logger5.error(
        `Failed to remove directory ${pluginDir}: ${rmError instanceof Error ? rmError.message : String(rmError)}`
      );
    }
  } else {
    const nonPrefixedDir = path10.join(cwd, baseName);
    if (existsSync9(nonPrefixedDir)) {
      try {
        rmSync(nonPrefixedDir, { recursive: true, force: true });
      } catch (rmError) {
        logger5.error(
          `Failed to remove directory ${nonPrefixedDir}: ${rmError instanceof Error ? rmError.message : String(rmError)}`
        );
      }
    }
  }
  console.log(`Successfully removed ${packageNameToRemove}`);
}

// src/commands/plugins/actions/list.ts
import { logger as logger6 } from "@elizaos/core";
async function listAvailablePlugins(opts) {
  const cachedRegistry = await fetchPluginRegistry();
  if (!cachedRegistry || !cachedRegistry.registry || Object.keys(cachedRegistry.registry).length === 0) {
    logger6.info("Plugin cache is empty or not found.");
    console.log('\nPlease run "elizaos plugins update" to fetch the latest plugin registry.');
    return;
  }
  let availablePluginsToDisplay = [];
  const allPlugins = cachedRegistry ? Object.entries(cachedRegistry.registry) : [];
  let displayTitle = "Available v1.x plugins";
  if (opts.all) {
    displayTitle = "All plugins in local cache (detailed view)";
    if (allPlugins.length === 0) {
      console.log("No plugins found in the registry.");
    }
    allPlugins.forEach(([name, info]) => {
      console.log(`
Plugin: ${name}`);
      const repoInfo = info.git?.repo || info.npm?.repo;
      console.log(`  Repository: ${repoInfo || "N/A"}`);
      console.log(`  v0 Compatible: ${info.supports.v0 ? "Yes" : "No"}`);
      if (info.npm?.v0 || info.git?.v0?.version) {
        const ver = info.npm?.v0 || info.git?.v0?.version;
        const branch = info.git?.v0?.branch;
        console.log(`    Version: ${ver || "N/A"}${branch ? ` (branch: ${branch})` : ""}`);
      }
      console.log(`  v1 Compatible: ${info.supports.v1 ? "Yes" : "No"}`);
      if (info.npm?.v1 || info.git?.v1?.version) {
        const ver = info.npm?.v1 || info.git?.v1?.version;
        const branch = info.git?.v1?.branch;
        console.log(`    Version: ${ver || "N/A"}${branch ? ` (branch: ${branch})` : ""}`);
      }
    });
    console.log("");
    return;
  } else if (opts.v0) {
    displayTitle = "Available v0.x plugins";
    availablePluginsToDisplay = allPlugins.filter(([, info]) => info.supports.v0).map(([name]) => name);
  } else {
    availablePluginsToDisplay = allPlugins.filter(([, info]) => info.supports.v1).map(([name]) => name);
  }
  logHeader(displayTitle);
  if (availablePluginsToDisplay.length === 0) {
    console.log("No plugins found matching the criteria in the registry.");
  } else {
    for (const pluginName of availablePluginsToDisplay) {
      console.log(`${pluginName}`);
    }
  }
  console.log("");
}
async function listInstalledPlugins() {
  const cwd = process.cwd();
  const directoryInfo = detectDirectoryType(cwd);
  if (!directoryInfo || !directoryInfo.hasPackageJson) {
    console.error(
      `Could not read or parse package.json. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
    );
    console.info("Please run this command from the root of an ElizaOS project.");
    process.exit(1);
  }
  const allDependencies = getDependenciesFromDirectory(cwd);
  if (!allDependencies) {
    console.error("Could not read dependencies from package.json.");
    process.exit(1);
  }
  const pluginNames = Object.keys(allDependencies).filter((depName) => {
    return /^(@elizaos(-plugins)?\/)?plugin-.+/.test(depName);
  });
  if (pluginNames.length === 0) {
    console.log("No Eliza plugins found in the project dependencies (package.json).");
  } else {
    logHeader("Plugins Added:");
    for (const pluginName of pluginNames) {
      console.log(`${pluginName}`);
    }
    console.log("");
  }
}

// src/commands/plugins/actions/upgrade.ts
import { logger as logger9 } from "@elizaos/core";
import path12 from "path";
import { existsSync as existsSync11 } from "fs";
import { fileURLToPath as fileURLToPath2 } from "url";
import fs from "fs-extra";

// src/utils/upgrade/simple-migration-agent.ts
import { query } from "@anthropic-ai/claude-code";

// src/utils/upgrade/migration-guide-loader.ts
import { existsSync as existsSync10, readFileSync as readFileSync3 } from "fs";
import path11 from "path";
import { fileURLToPath } from "url";
import { logger as logger7 } from "@elizaos/core";
var MigrationGuideLoader = class {
  guides = [];
  guidesDir;
  constructor(projectRoot) {
    this.guidesDir = this.findGuidesDirectory(projectRoot);
    this.loadGuides();
  }
  findGuidesDirectory(projectRoot) {
    if (projectRoot) {
      const guidesPath = path11.join(projectRoot, "packages/docs/docs/plugins/migration/claude-code");
      if (existsSync10(guidesPath)) {
        return guidesPath;
      }
    }
    let currentRoot = process.cwd();
    let previousRoot = "";
    while (currentRoot !== previousRoot && !existsSync10(path11.join(currentRoot, "packages/docs"))) {
      previousRoot = currentRoot;
      currentRoot = path11.dirname(currentRoot);
    }
    const monorepoGuidesPath = path11.join(
      currentRoot,
      "packages/docs/docs/plugins/migration/claude-code"
    );
    if (existsSync10(monorepoGuidesPath)) {
      return monorepoGuidesPath;
    }
    const workingDirGuides = path11.join(process.cwd(), "migration-guides");
    if (existsSync10(workingDirGuides)) {
      return workingDirGuides;
    }
    const currentFileUrl = import.meta.url;
    const currentFilePath = fileURLToPath(currentFileUrl);
    const cliPackageRoot = path11.dirname(path11.dirname(path11.dirname(path11.dirname(currentFilePath))));
    const bundledGuidesPath = path11.join(cliPackageRoot, "migration-guides");
    if (existsSync10(bundledGuidesPath)) {
      return bundledGuidesPath;
    }
    return "";
  }
  loadGuides() {
    const guideConfigs = [
      {
        name: "migration-guide.md",
        category: "basic",
        keywords: [
          "import",
          "path",
          "action",
          "provider",
          "basic",
          "core",
          "elizaLogger",
          "logger",
          "IAgentRuntime",
          "AgentRuntime",
          "Account",
          "Entity",
          "composeContext",
          "generateObject",
          "package.json",
          "dependencies",
          "scripts",
          "build"
        ]
      },
      {
        name: "state-and-providers-guide.md",
        category: "basic",
        keywords: [
          "state",
          "provider",
          "ProviderResult",
          "context",
          "memory",
          "runtime",
          "world",
          "room",
          "entityId",
          "userId",
          "optional"
        ]
      },
      {
        name: "prompt-and-generation-guide.md",
        category: "basic",
        keywords: [
          "template",
          "prompt",
          "generation",
          "XML",
          "JSON",
          "useModel",
          "generateText",
          "messages",
          "format"
        ]
      },
      {
        name: "advanced-migration-guide.md",
        category: "advanced",
        keywords: [
          "service",
          "evaluator",
          "settings",
          "singleton",
          "lifecycle",
          "initialize",
          "start",
          "stop",
          "client",
          "complex"
        ]
      },
      {
        name: "testing-guide.md",
        category: "testing",
        keywords: [
          "test",
          "coverage",
          "vitest",
          "bun",
          "mock",
          "unit",
          "integration",
          "error",
          "edge",
          "performance",
          "test-utils"
        ]
      },
      {
        name: "completion-requirements.md",
        category: "completion",
        keywords: [
          "release",
          "workflow",
          "npm",
          "deploy",
          "gitignore",
          "npmignore",
          "license",
          "prettier",
          "final",
          "validation"
        ]
      }
    ];
    if (!this.guidesDir || !existsSync10(this.guidesDir)) {
      logger7.info("Using embedded migration guidance (external CLI mode)");
      this.createEmbeddedGuides(guideConfigs);
      return;
    }
    for (const config2 of guideConfigs) {
      const guidePath = path11.join(this.guidesDir, config2.name);
      if (existsSync10(guidePath)) {
        try {
          const content = readFileSync3(guidePath, "utf-8");
          this.guides.push({
            name: config2.name,
            path: guidePath,
            content,
            category: config2.category,
            keywords: config2.keywords
          });
        } catch (error) {
          logger7.warn(`Failed to load migration guide: ${config2.name}`, error);
        }
      } else {
        logger7.warn(`Migration guide not found: ${guidePath}`);
      }
    }
    logger7.info(`Loaded ${this.guides.length} migration guides from ${this.guidesDir}`);
  }
  createEmbeddedGuides(guideConfigs) {
    const embeddedGuides = {
      "migration-guide.md": this.getEmbeddedMigrationGuide(),
      "testing-guide.md": this.getEmbeddedTestingGuide(),
      "completion-requirements.md": this.getEmbeddedCompletionGuide()
    };
    for (const config2 of guideConfigs) {
      const embeddedContent = embeddedGuides[config2.name];
      if (embeddedContent) {
        this.guides.push({
          name: config2.name,
          path: `embedded:${config2.name}`,
          content: embeddedContent,
          category: config2.category,
          keywords: config2.keywords
        });
      }
    }
  }
  getEmbeddedMigrationGuide() {
    return `# ElizaOS Plugin Migration Guide - Essential Steps

## Core Migration Requirements

### 1. Import Path Updates
- elizaLogger \u2192 logger
- IAgentRuntime \u2192 AgentRuntime  
- Account \u2192 Entity
- userId \u2192 entityId

### 2. Package.json Updates
- Update to @elizaos/core ^1.0.0
- Update scripts to use bun
- Add proper exports and types

### 3. Action Migration
- Replace composeContext with new patterns
- Convert JSON templates to XML
- Update generateObject to runtime.useModel
- Fix handler patterns

### 4. Provider Migration  
- Add name property
- Return ProviderResult
- Make state parameter required

### 5. Testing Requirements
- Use bun test framework
- Achieve 95%+ coverage
- Test all components thoroughly

For complete details, refer to the comprehensive guides in the ElizaOS documentation.`;
  }
  getEmbeddedTestingGuide() {
    return `# ElizaOS Testing Guide - Essential Requirements

## Test Framework
- Use bun test (not vitest)
- Achieve 95%+ code coverage
- Test all actions, providers, evaluators

## Test Structure
\`\`\`
src/__tests__/
\u251C\u2500\u2500 test-utils.ts
\u251C\u2500\u2500 actions/
\u251C\u2500\u2500 providers/
\u2514\u2500\u2500 evaluators/
\`\`\`

## Coverage Requirements
- All components must be tested
- Error cases must be covered
- Edge cases must be handled
- Integration tests required

## Common Issues
- Mock all async dependencies
- Clean up after each test
- Use proper test isolation

Run: bun test --coverage`;
  }
  getEmbeddedCompletionGuide() {
    return `# ElizaOS Completion Requirements

## Required Files
- .gitignore
- .npmignore  
- LICENSE
- .prettierrc
- .github/workflows/npm-deploy.yml

## Final Validation
\`\`\`bash
bun run build     # Must pass
bun test          # Must pass  
bunx tsc --noEmit # Must pass
\`\`\`

## Package.json Requirements
- Correct name format
- Version 1.0.0
- Proper exports
- Build scripts
- Test scripts

## Release Workflow
- GitHub workflow for npm publish
- Automated testing
- Version management`;
  }
  /**
   * Search for relevant guides based on keywords or content
   */
  searchGuides(query2, limit = 3) {
    const queryLower = query2.toLowerCase();
    const queryWords = queryLower.split(/\s+/).filter((word) => word.length > 2);
    const results = [];
    for (const guide of this.guides) {
      let relevanceScore = 0;
      const matchedKeywords = [];
      for (const keyword of guide.keywords) {
        if (queryWords.some((word) => keyword.toLowerCase().includes(word))) {
          relevanceScore += 2;
          matchedKeywords.push(keyword);
        }
      }
      const contentLower = guide.content.toLowerCase();
      for (const word of queryWords) {
        const matches = (contentLower.match(new RegExp(word, "g")) || []).length;
        relevanceScore += matches * 0.5;
      }
      if (queryLower.includes("import") && guide.name === "migration-guide.md") {
        relevanceScore += 3;
      }
      if (queryLower.includes("test") && guide.name === "testing-guide.md") {
        relevanceScore += 3;
      }
      if (queryLower.includes("state") && guide.name === "state-and-providers-guide.md") {
        relevanceScore += 3;
      }
      if (relevanceScore > 0) {
        results.push({
          guide,
          relevanceScore,
          matchedKeywords
        });
      }
    }
    return results.sort((a, b) => b.relevanceScore - a.relevanceScore).slice(0, limit);
  }
  /**
   * Get a specific guide by name
   */
  getGuide(name) {
    return this.guides.find((guide) => guide.name === name) || null;
  }
  /**
   * Get all guides of a specific category
   */
  getGuidesByCategory(category) {
    return this.guides.filter((guide) => guide.category === category);
  }
  /**
   * Get guides that are most relevant for common migration issues
   */
  getRelevantGuidesForIssue(issue) {
    const issueMap = {
      import_error: ["import", "path", "elizaLogger", "logger"],
      build_error: ["build", "typescript", "package.json", "dependencies"],
      type_error: ["typescript", "type", "IAgentRuntime", "AgentRuntime"],
      action_migration: ["action", "composeContext", "generateObject", "handler"],
      provider_migration: ["provider", "ProviderResult", "state", "context"],
      test_failure: ["test", "coverage", "mock", "unit"],
      service_migration: ["service", "lifecycle", "initialize", "singleton"],
      template_migration: ["template", "XML", "JSON", "prompt"],
      release_setup: ["release", "workflow", "npm", "deploy"]
    };
    const keywords = issueMap[issue];
    if (!keywords) {
      return this.searchGuides(issue);
    }
    return this.searchGuides(keywords.join(" "));
  }
  /**
   * Generate a comprehensive migration context for Claude
   */
  generateMigrationContext() {
    const context = [
      "# ELIZAOS PLUGIN MIGRATION GUIDE REFERENCES",
      "",
      "You have access to the following comprehensive migration guides:",
      ""
    ];
    for (const guide of this.guides) {
      context.push(`## ${guide.name.replace(".md", "").toUpperCase()}`);
      context.push(`Category: ${guide.category}`);
      context.push(`Keywords: ${guide.keywords.join(", ")}`);
      context.push("");
      const preview = guide.content.substring(0, 500).replace(/\n/g, " ");
      context.push(`Preview: ${preview}...`);
      context.push("");
      context.push("---");
      context.push("");
    }
    context.push("## GUIDE USAGE INSTRUCTIONS");
    context.push("");
    context.push("- Reference specific guides for detailed migration steps");
    context.push("- Use migration-guide.md for basic actions and providers");
    context.push("- Use advanced-migration-guide.md for services and evaluators");
    context.push("- Use testing-guide.md for comprehensive test coverage");
    context.push("- Use completion-requirements.md for final release preparation");
    context.push("");
    return context.join("\n");
  }
  /**
   * Get full content of all guides for RAG embedding
   */
  getAllGuidesContent() {
    const content = [
      "# COMPLETE ELIZAOS MIGRATION KNOWLEDGE BASE",
      "",
      "This contains all migration guides and their complete content for reference.",
      ""
    ];
    for (const guide of this.guides) {
      content.push(`# GUIDE: ${guide.name}`);
      content.push(`Category: ${guide.category}`);
      content.push(`Keywords: ${guide.keywords.join(", ")}`);
      content.push("");
      content.push("## CONTENT:");
      content.push("");
      content.push(guide.content);
      content.push("");
      content.push("---");
      content.push("");
    }
    return content.join("\n");
  }
};
function createMigrationGuideLoader(projectRoot) {
  return new MigrationGuideLoader(projectRoot);
}

// src/utils/upgrade/simple-migration-agent.ts
import { logger as logger8 } from "@elizaos/core";
var SimpleMigrationAgent = class extends EventTarget {
  handlers = /* @__PURE__ */ new Map();
  repoPath;
  abortController;
  verbose;
  guideLoader;
  spinnerInterval = null;
  spinnerFrame = 0;
  spinnerFrames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
  // Token and cost tracking
  totalInputTokens = 0;
  totalOutputTokens = 0;
  totalCost = 0;
  lastTokenUpdate = Date.now();
  lastCostSummary = Date.now();
  constructor(repoPath, options = {}) {
    super();
    this.repoPath = repoPath;
    this.abortController = new AbortController();
    this.verbose = options.verbose || false;
    try {
      this.guideLoader = createMigrationGuideLoader();
      if (this.verbose) {
        logger8.info("Migration guide loader initialized successfully");
      }
    } catch (error) {
      logger8.warn("Failed to initialize migration guide loader", error);
      throw new Error("Cannot initialize migration system without guide access");
    }
  }
  // EventEmitter-like API using native EventTarget
  emit(event, data) {
    return this.dispatchEvent(new CustomEvent(event, { detail: data }));
  }
  on(event, handler) {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, /* @__PURE__ */ new Map());
    }
    const eventHandlers = this.handlers.get(event);
    if (eventHandlers.has(handler)) {
      return this;
    }
    const wrappedHandler = (e) => {
      if (e instanceof CustomEvent) {
        handler(e.detail);
      } else {
        handler(void 0);
      }
    };
    eventHandlers.set(handler, wrappedHandler);
    this.addEventListener(event, wrappedHandler);
    return this;
  }
  off(event, handler) {
    const eventHandlers = this.handlers.get(event);
    const wrappedHandler = eventHandlers?.get(handler);
    if (wrappedHandler) {
      this.removeEventListener(event, wrappedHandler);
      eventHandlers.delete(handler);
      if (eventHandlers.size === 0) {
        this.handlers.delete(event);
      }
    }
  }
  // Alias for EventEmitter compatibility
  removeListener(event, handler) {
    return this.off(event, handler);
  }
  removeAllListeners(event) {
    if (event) {
      const eventHandlers = this.handlers.get(event);
      if (eventHandlers) {
        for (const [_, wrappedHandler] of eventHandlers) {
          this.removeEventListener(event, wrappedHandler);
        }
        this.handlers.delete(event);
      }
    } else {
      for (const [eventName, eventHandlers] of this.handlers) {
        for (const [_, wrappedHandler] of eventHandlers) {
          this.removeEventListener(eventName, wrappedHandler);
        }
      }
      this.handlers.clear();
    }
  }
  listenerCount(event) {
    return this.handlers.get(event)?.size || 0;
  }
  listeners(event) {
    const eventHandlers = this.handlers.get(event);
    return eventHandlers ? Array.from(eventHandlers.keys()) : [];
  }
  isImportantUpdate(text3) {
    const importantPatterns = [
      /GATE \d+/i,
      /analysis/i,
      /migration/i,
      /complete/i,
      /success/i,
      /error/i,
      /building/i,
      /testing/i,
      /upgrading/i,
      /validating/i,
      /fixing/i,
      /installing/i,
      /processing/i,
      /checking/i,
      /updating/i,
      /✓|✗|🎉|🚀|📊|⚡|🔍|🔨|🧪|📝|📖|✏️|📄/,
      /^(Starting|Finishing|Completed)/i,
      /^[A-Z][a-z]+ (plugin|package|file|test)/i
      // Actions on specific items
    ];
    return importantPatterns.some((pattern) => pattern.test(text3)) && text3.length < 300;
  }
  formatProgressUpdate(text3) {
    text3 = text3.trim();
    const timestamp = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
      hour12: false,
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
    if (text3.includes("GATE")) {
      return `
\u{1F3AF} [${timestamp}] ${text3}`;
    } else if (text3.includes("complete") || text3.includes("\u2713") || text3.includes("success")) {
      return `\u2705 [${timestamp}] ${text3}`;
    } else if (text3.includes("error") || text3.includes("\u2717") || text3.includes("failed")) {
      return `\u274C [${timestamp}] ${text3}`;
    } else if (text3.includes("analyzing") || text3.includes("analysis")) {
      return `\u{1F50D} [${timestamp}] ${text3}`;
    } else if (text3.includes("migrating") || text3.includes("migration") || text3.includes("upgrading")) {
      return `\u{1F504} [${timestamp}] ${text3}`;
    } else if (text3.includes("building") || text3.includes("compile")) {
      return `\u{1F528} [${timestamp}] ${text3}`;
    } else if (text3.includes("testing") || text3.includes("test")) {
      return `\u{1F9EA} [${timestamp}] ${text3}`;
    } else if (text3.includes("installing") || text3.includes("install")) {
      return `\u{1F4E6} [${timestamp}] ${text3}`;
    } else if (text3.includes("validating") || text3.includes("validation")) {
      return `\u2714\uFE0F  [${timestamp}] ${text3}`;
    } else if (text3.includes("fixing") || text3.includes("fix")) {
      return `\u{1F527} [${timestamp}] ${text3}`;
    } else if (text3.includes("Starting") || text3.includes("Initializing")) {
      return `\u{1F680} [${timestamp}] ${text3}`;
    } else if (text3.includes("Finishing") || text3.includes("Completed")) {
      return `\u{1F3C1} [${timestamp}] ${text3}`;
    }
    return `\u{1F4AD} [${timestamp}] ${text3}`;
  }
  startSpinner(message) {
    if (this.spinnerInterval) {
      this.stopSpinner();
    }
    process.stdout.write(`${message} `);
    this.spinnerInterval = setInterval(() => {
      process.stdout.write(`\r${message} ${this.spinnerFrames[this.spinnerFrame]}`);
      this.spinnerFrame = (this.spinnerFrame + 1) % this.spinnerFrames.length;
    }, 100);
  }
  stopSpinner(completionMessage) {
    if (this.spinnerInterval) {
      clearInterval(this.spinnerInterval);
      this.spinnerInterval = null;
      if (completionMessage) {
        process.stdout.write(`\r${completionMessage}
`);
      } else {
        process.stdout.write("\r");
        process.stdout.clearLine(0);
      }
    }
  }
  updateTokenTracking(usage) {
    if (usage.input_tokens) {
      this.totalInputTokens += usage.input_tokens;
    }
    if (usage.output_tokens) {
      this.totalOutputTokens += usage.output_tokens;
    }
    const inputCostPer1k = 3e-3;
    const outputCostPer1k = 0.015;
    if (usage.input_tokens) {
      this.totalCost += usage.input_tokens / 1e3 * inputCostPer1k;
    }
    if (usage.output_tokens) {
      this.totalCost += usage.output_tokens / 1e3 * outputCostPer1k;
    }
    this.lastTokenUpdate = Date.now();
  }
  formatTokenDisplay() {
    if (this.totalInputTokens === 0 && this.totalOutputTokens === 0) {
      return "";
    }
    const totalTokens = this.totalInputTokens + this.totalOutputTokens;
    const costDisplay = this.totalCost > 0 ? ` ($${this.totalCost.toFixed(4)})` : "";
    return ` | \u{1F3A9} ${totalTokens.toLocaleString()} tokens${costDisplay}`;
  }
  getSimplifiedToolName(toolName) {
    const toolMap = {
      TodoWrite: "\u{1F4DD} Planning",
      TodoRead: "\u{1F4CB} Checking",
      Bash: "\u26A1 Running",
      Read: "\u{1F4D6} Reading",
      Edit: "\u270F\uFE0F  Editing",
      MultiEdit: "\u{1F4DD} Batch editing",
      Write: "\u{1F4C4} Writing",
      LS: "\u{1F50D} Exploring",
      Glob: "\u{1F50E} Pattern matching",
      Grep: "\u{1F50D} Searching",
      Task: "\u{1F527} Processing",
      WebFetch: "\u{1F310} Fetching",
      WebSearch: "\u{1F50D} Web searching",
      NotebookRead: "\u{1F4D3} Notebook reading",
      NotebookEdit: "\u{1F4DD} Notebook editing"
    };
    return toolMap[toolName] || `\u{1F6E0}\uFE0F  ${toolName}`;
  }
  async migrate() {
    const startTime = Date.now();
    let messageCount = 0;
    try {
      process.env.CLAUDE_CODE_ENABLE_TELEMETRY = "0";
      process.env.OTEL_LOGS_EXPORTER = "";
      process.env.OTEL_LOG_USER_PROMPTS = "0";
      process.env.OTEL_METRICS_EXPORTER = "";
      console.log("Claude is analyzing and migrating your plugin...\n");
      this.emit("start");
      this.startSpinner("\u{1F50E} Initializing Claude Code SDK...");
      console.log(`Starting migration in directory: ${this.repoPath}`);
      const migrationContext = this.guideLoader.getAllGuidesContent();
      const guideReferences = this.guideLoader.generateMigrationContext();
      const migrationPrompt = `You are about to help migrate an ElizaOS plugin from 0.x to 1.x format.

CRITICAL: You must follow the INTEGRATED EXECUTION PROTOCOL exactly as specified in the CLAUDE.md file.

This is a GATED PROCESS with 9 gates (0-8). You CANNOT skip steps.

COMPREHENSIVE MIGRATION KNOWLEDGE BASE:
${migrationContext}

GUIDE REFERENCE SYSTEM:
${guideReferences}

REFERENCE GUIDES are in migration-guides/ directory:
- migration-guide.md (basic migration steps)
- state-and-providers-guide.md (state & providers migration)
- prompt-and-generation-guide.md (templates & generation)
- advanced-migration-guide.md (services, settings, evaluators)
- testing-guide.md (comprehensive testing requirements)
- completion-requirements.md (final validation and release preparation)

ENHANCED RAG CAPABILITIES:
You have access to the complete content of all migration guides above. Use this knowledge to:
1. Provide specific, detailed migration steps
2. Reference exact sections from the appropriate guides
3. Troubleshoot specific issues with targeted solutions
4. Ensure comprehensive coverage of all migration requirements

CRITICAL TEST VALIDATION REQUIREMENTS - ABSOLUTE REQUIREMENTS

MIGRATION CANNOT BE COMPLETED UNTIL ALL TESTS PASS

Throughout the migration process, you MUST validate these requirements and loop until they pass:

1. MANDATORY TEST VALIDATION LOOP: After every significant code change, run:
   - bun run test - ALL tests must pass (100% success rate, ZERO failures)
   - bunx tsc --noEmit - ZERO TypeScript errors in src/ directory
   - Only test files can have type errors, src/ must be error-free

2. CONTINUOUS VALIDATION LOOP: If ANY of these fail:
   - Analyze the errors thoroughly
   - Fix all issues identified
   - Re-run the validation commands
   - Repeat until BOTH commands succeed with zero errors
   - DO NOT PROCEED until validation passes

3. COVERAGE VS TEST CONFLICTS: If tests conflict with 95% coverage requirements:
   - Prioritize making tests pass over coverage percentage
   - Use workarounds like test mocks, stubs, or simplified implementations
   - Lower coverage if necessary - tests passing is more important
   - Add // @ts-ignore comments if needed for test compatibility

4. RELEASE WORKFLOW REQUIREMENT: The .github/workflows/release.yml requires bun run test to pass before npm publish. Migration is NOT complete until all tests pass.

5. ABSOLUTE REQUIREMENTS - NO EXCEPTIONS:
   - bun run test MUST show 0 failing tests
   - If ANY test fails, the migration is INCOMPLETE
   - Do not declare success until bun run test passes completely
   - Work around any test issues rather than leaving them failing

START WITH GATE 0: Create 1.x branch
Execute: git checkout -b 1.x
Gate Check: git branch --show-current must output "1.x"

THEN GATE 1: Complete analysis following the exact format in the integrated-migration-loop.md

DO NOT PROCEED until each gate check passes AND all validation requirements are met.

Remember: You must grind on test failures and TypeScript errors until they are 100% resolved. The release workflow will fail if tests don't pass.

FINAL VALIDATION REQUIREMENTS (GATE 8+) - ABSOLUTELY MANDATORY

THE MIGRATION IS NOT COMPLETE UNTIL EVERY SINGLE TEST PASSES

After completing all 9 gates, you MUST perform final validation and loop until both pass:

FINAL VALIDATION LOOP - REPEAT UNTIL SUCCESS:
1. Run: bun run test
   - MUST pass 100% - this is required for npm release workflow
   - If ANY tests fail, analyze and fix them, then retry
   - Use workarounds, mocks, simplified implementations if needed
   - Lower coverage requirements if tests conflict with coverage
   - Do NOT declare migration complete until this shows ZERO failures

2. Run: bunx tsc --noEmit  
   - MUST have ZERO errors in src/ directory
   - Test files can have type errors as exception, but fix if possible
   - If any src/ errors exist, fix them and retry

3. REPEAT FINAL VALIDATION LOOP until both commands succeed with zero errors
   - Keep trying different approaches
   - Simplify tests if needed
   - Use test mocks and stubs
   - Do whatever it takes to make tests pass

4. Only AFTER both final validations pass with ZERO failures, declare migration complete

ABSOLUTE REQUIREMENT: The migration is NOT complete until bun run test shows zero failures. The release workflow will fail otherwise. NO EXCEPTIONS.`;
      let queryGenerator;
      try {
        queryGenerator = query({
          prompt: migrationPrompt,
          abortController: this.abortController,
          options: {
            cwd: this.repoPath,
            model: "opus",
            permissionMode: "bypassPermissions"
          }
        });
      } catch (queryError) {
        const errorMessage = queryError instanceof Error ? queryError.message : String(queryError);
        throw new Error(`Failed to initialize Claude Code SDK query: ${errorMessage}`);
      }
      let currentToolName = null;
      let toolStartTime = null;
      let lastProgressUpdate = Date.now();
      for await (const message of queryGenerator) {
        messageCount++;
        try {
          if (message.type === "assistant") {
            if (message.message && message.message.content) {
              const content = message.message.content;
              if (Array.isArray(content)) {
                for (const block of content) {
                  if (block.type === "text") {
                    const text3 = block.text;
                    if (this.isImportantUpdate(text3)) {
                      if (currentToolName) {
                        process.stdout.write(" \u2713\n");
                        currentToolName = null;
                      }
                      let formattedText = this.formatProgressUpdate(text3);
                      if (text3.includes("GATE") && (this.totalInputTokens > 0 || this.totalOutputTokens > 0)) {
                        const tokenInfo = this.formatTokenDisplay();
                        formattedText += tokenInfo;
                      }
                      console.log(formattedText);
                    } else if (this.verbose && text3.length > 10 && text3.length < 100) {
                      console.log(`\u{1F4AC} ${text3.trim()}`);
                    }
                  } else if (block.type === "tool_use") {
                    const toolName = this.getSimplifiedToolName(block.name);
                    if (toolName) {
                      if (currentToolName) {
                        const duration = toolStartTime ? Date.now() - toolStartTime : 0;
                        process.stdout.write(` \u2713 (${Math.round(duration / 1e3)}s)
`);
                      }
                      process.stdout.write(`${toolName}...`);
                      currentToolName = toolName;
                      toolStartTime = Date.now();
                    }
                  }
                }
              } else if (typeof content === "string") {
                if (this.isImportantUpdate(content)) {
                  if (currentToolName) {
                    process.stdout.write(" \u2713\n");
                    currentToolName = null;
                  }
                  console.log(this.formatProgressUpdate(content));
                }
              }
            }
          }
          if ("type" in message && message.type === "tool_result") {
            if (currentToolName) {
              const duration = toolStartTime ? Date.now() - toolStartTime : 0;
              process.stdout.write(` \u2713 (${Math.round(duration / 1e3)}s)
`);
              currentToolName = null;
              toolStartTime = null;
            }
          }
          if (message.type === "result") {
            if (currentToolName) {
              process.stdout.write(" \u2713\n");
              currentToolName = null;
            }
            console.log(`

\u{1F4CA} Migration Summary:`);
            console.log(`\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500`);
            console.log(`Status: ${message.subtype === "success" ? "\u2705 Completed" : "\u274C Failed"}`);
            const finalCost = message.total_cost_usd || this.totalCost;
            if (finalCost > 0) {
              console.log(`\u{1F4B0} Total Cost: $${finalCost.toFixed(4)}`);
            }
            if (this.totalInputTokens > 0 || this.totalOutputTokens > 0) {
              console.log(
                `\u{1F3A9} Token Usage: \u2192${this.totalInputTokens.toLocaleString()} in, \u2190${this.totalOutputTokens.toLocaleString()} out (${(this.totalInputTokens + this.totalOutputTokens).toLocaleString()} total)`
              );
            }
            if (message.duration_ms)
              console.log(`\u23F1\uFE0F  Duration: ${Math.round(message.duration_ms / 1e3)}s`);
            if (message.num_turns) console.log(`\u{1F916} AI Operations: ${message.num_turns}`);
            console.log(`\u{1F4EC} Total Messages: ${messageCount}`);
            console.log("");
          }
          if (message.type === "system" && message.subtype === "init") {
            this.stopSpinner("\u{1F680} Migration session started");
            console.log("");
          }
        } catch (messageError) {
          if (this.verbose) {
            const errorMessage = messageError instanceof Error ? messageError.message : String(messageError);
            console.log(`
\u26A0\uFE0F  Message processing error: ${errorMessage}`);
          }
        }
        const now = Date.now();
        if (messageCount % 15 === 0 && now - lastProgressUpdate > 5e3) {
          if (currentToolName) {
            process.stdout.write("\n");
          }
          const tokenInfo = this.formatTokenDisplay();
          console.log(
            `
\u23F3 Processing... (${messageCount} operations, ${Math.round((now - startTime) / 1e3)}s elapsed${tokenInfo})
`
          );
          this.emit("progress", messageCount);
          lastProgressUpdate = now;
          if (currentToolName) {
            process.stdout.write(`${currentToolName}...`);
          }
        }
        if (message.type === "assistant" && "usage" in message) {
          this.updateTokenTracking(message.usage);
          const timeSinceCostSummary = now - this.lastCostSummary;
          if (timeSinceCostSummary > 3e4 && this.totalInputTokens > 0) {
            if (currentToolName) {
              process.stdout.write("\n");
            }
            console.log(
              `\u{1F4B0} Cost Update: $${this.totalCost.toFixed(4)} | \u{1F3A9} ${(this.totalInputTokens + this.totalOutputTokens).toLocaleString()} tokens used`
            );
            this.lastCostSummary = now;
            if (currentToolName) {
              process.stdout.write(`${currentToolName}...`);
            }
          }
        }
      }
      this.stopSpinner();
      if (currentToolName) {
        process.stdout.write(" \u2713\n");
      }
      console.log("\n\u{1F389} Migration completed successfully!");
      console.log(`\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500`);
      const guidesUsed = this.guideLoader.getGuidesByCategory("basic").concat(this.guideLoader.getGuidesByCategory("advanced")).concat(this.guideLoader.getGuidesByCategory("testing")).concat(this.guideLoader.getGuidesByCategory("completion")).map((guide) => guide.name);
      return {
        success: true,
        repoPath: this.repoPath,
        duration: Date.now() - startTime,
        messageCount,
        guidesUsed
      };
    } catch (error) {
      console.log("\n\u274C Migration failed");
      console.log(`\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500`);
      if (error instanceof Error) {
        console.log(`\u{1F4DC} Error Type: ${error.name}`);
        console.log(`\u{1F4AC} Error Message: ${error.message}`);
        if (error.message.includes("API key")) {
          console.log("\n\u{1F511} API Key Issue Detected:");
          console.log("  \u2022 Verify ANTHROPIC_API_KEY is set correctly");
          console.log('  \u2022 Ensure the key starts with "sk-ant-"');
          console.log("  \u2022 Check your key has sufficient credits");
        } else if (error.message.includes("timeout") || error.message.includes("network")) {
          console.log("\n\u{1F310} Network Issue Detected:");
          console.log("  \u2022 Check your internet connection");
          console.log("  \u2022 Try again in a few moments");
          console.log("  \u2022 Consider using --timeout option for slower connections");
        } else if (error.message.includes("permission") || error.message.includes("access")) {
          console.log("\n\u{1F512} Permission Issue Detected:");
          console.log("  \u2022 Ensure you have write access to the plugin directory");
          console.log("  \u2022 Check file permissions");
          console.log("  \u2022 Try running from a directory you own");
        }
        if (this.verbose) {
          console.log(`
\u{1F50E} Full Stack Trace:`);
          console.log(error.stack || "No stack trace available");
        }
      } else {
        console.log(`\u{1F4AC} Error Details:`, error);
      }
      console.log("\n\u{1F527} Recovery Options:");
      console.log("  1. Check git status and stash/commit changes if needed");
      console.log("  2. Verify plugin structure follows ElizaOS standards");
      console.log("  3. Try running with --verbose for detailed output");
      console.log("  4. Check network connectivity and API key validity");
      console.log('  5. Ensure all dependencies are installed with "bun install"');
      return {
        success: false,
        repoPath: this.repoPath,
        duration: Date.now() - startTime,
        messageCount,
        error
      };
    }
  }
  abort() {
    this.stopSpinner();
    console.log("\n\u2639\uFE0F  Migration aborted by user");
    if (this.totalInputTokens > 0 || this.totalOutputTokens > 0) {
      console.log(
        `\u{1F4B0} Partial cost: $${this.totalCost.toFixed(4)} | \u{1F3A9} ${(this.totalInputTokens + this.totalOutputTokens).toLocaleString()} tokens used`
      );
    }
    console.log(`\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500`);
    console.log("\u{1F5FA}\uFE0F  What happened:");
    console.log("   \u2022 Migration process was interrupted");
    console.log("   \u2022 Plugin files may be in partial state");
    console.log("   \u2022 Some changes may have been applied");
    console.log("\n\u{1F527} Recommended next steps:");
    console.log("   1. Check git status to see what changed");
    console.log('   2. Use "git checkout ." to revert uncommitted changes if needed');
    console.log("   3. Review any migration-guides/ directory that may have been created");
    console.log('   4. Clean up with "rm -rf migration-guides/" if present');
    console.log("   5. Try migration again when ready");
    this.abortController.abort();
    this.emit("aborted");
  }
  /**
   * Get migration help for specific issues
   */
  getMigrationHelp(issue) {
    try {
      const results = this.guideLoader.getRelevantGuidesForIssue(issue);
      if (results.length === 0) {
        return `No specific guidance found for: ${issue}
Check the basic migration-guide.md for general steps.`;
      }
      const help = [
        `MIGRATION GUIDANCE FOR: ${issue.toUpperCase()}`,
        "",
        "Relevant guides found:",
        ""
      ];
      for (const result of results) {
        help.push(`## ${result.guide.name}`);
        help.push(`Relevance Score: ${result.relevanceScore.toFixed(1)}`);
        help.push(`Matched Keywords: ${result.matchedKeywords.join(", ")}`);
        help.push(`Category: ${result.guide.category}`);
        help.push("");
      }
      return help.join("\n");
    } catch (error) {
      return `Error getting migration help: ${error instanceof Error ? error.message : String(error)}`;
    }
  }
  /**
   * Search guides for specific content
   */
  searchGuides(query2, limit = 3) {
    try {
      const results = this.guideLoader.searchGuides(query2, limit);
      if (results.length === 0) {
        return `No guides found matching: ${query2}`;
      }
      const searchResults = [
        `SEARCH RESULTS FOR: ${query2}`,
        "",
        `Found ${results.length} relevant guide(s):`,
        ""
      ];
      for (const result of results) {
        searchResults.push(`## ${result.guide.name}`);
        searchResults.push(`Score: ${result.relevanceScore.toFixed(1)}`);
        searchResults.push(`Keywords: ${result.matchedKeywords.join(", ")}`);
        searchResults.push(`Path: ${result.guide.path}`);
        searchResults.push("");
      }
      return searchResults.join("\n");
    } catch (error) {
      return `Error searching guides: ${error instanceof Error ? error.message : String(error)}`;
    }
  }
  /**
   * Get complete migration context for debugging
   */
  getFullMigrationContext() {
    try {
      return this.guideLoader.getAllGuidesContent();
    } catch (error) {
      return `Error getting migration context: ${error instanceof Error ? error.message : String(error)}`;
    }
  }
};

// src/commands/plugins/actions/upgrade.ts
import chalk from "chalk";
async function upgradePlugin(pluginPath, opts) {
  try {
    if (opts.apiKey) {
      process.env.ANTHROPIC_API_KEY = opts.apiKey;
    }
    if (!process.env.ANTHROPIC_API_KEY) {
      logger9.error("ANTHROPIC_API_KEY is required for plugin upgrade.");
      console.log("\nPlease set ANTHROPIC_API_KEY environment variable or use --api-key option.");
      console.log("Get your API key from: https://console.anthropic.com/");
      process.exit(1);
    }
    if (!process.env.ANTHROPIC_API_KEY.startsWith("sk-ant-")) {
      logger9.error("Invalid ANTHROPIC_API_KEY format.");
      console.log('\nThe API key should start with "sk-ant-"');
      console.log("Get your API key from: https://console.anthropic.com/");
      process.exit(1);
    }
    try {
      await import("@anthropic-ai/claude-code");
      if (opts.debug) {
        console.log("\u2713 Claude Code SDK ready");
      }
    } catch (importError) {
      console.log(chalk.red("\u2717 Claude Code SDK not available"));
      console.log(
        chalk.red(
          `Error: ${importError instanceof Error ? importError.message : String(importError)}`
        )
      );
      console.log("\nInstall the SDK: bun add @anthropic-ai/claude-code");
      process.exit(1);
    }
    const workingDir = path12.resolve(pluginPath);
    if (!existsSync11(workingDir)) {
      throw new Error(`Plugin directory not found: ${workingDir}`);
    }
    console.log(chalk.cyan("\u{1F527} Setting up migration environment..."));
    let projectRoot = process.cwd();
    let guidesSource;
    let previousRoot = "";
    while (projectRoot !== previousRoot && !existsSync11(path12.join(projectRoot, "packages/docs"))) {
      previousRoot = projectRoot;
      projectRoot = path12.dirname(projectRoot);
    }
    const monorepoGuidesPath = path12.join(
      projectRoot,
      "packages/docs/docs/plugins/migration/claude-code"
    );
    if (existsSync11(monorepoGuidesPath)) {
      guidesSource = monorepoGuidesPath;
    } else {
      const currentFileUrl = import.meta.url;
      const currentFilePath = fileURLToPath2(currentFileUrl);
      const cliPackageRoot = path12.dirname(
        path12.dirname(path12.dirname(path12.dirname(currentFilePath)))
      );
      const bundledGuidesPath = path12.join(cliPackageRoot, "migration-guides");
      if (existsSync11(bundledGuidesPath)) {
        guidesSource = bundledGuidesPath;
      } else {
        guidesSource = "";
      }
    }
    const guidesTarget = path12.join(workingDir, "migration-guides");
    await fs.ensureDir(guidesTarget);
    if (guidesSource && existsSync11(guidesSource)) {
      await fs.copy(guidesSource, guidesTarget, { overwrite: true });
      if (opts.debug) {
        console.log(chalk.gray(`Copied guides from: ${guidesSource}`));
      }
    } else {
      if (opts.debug) {
        console.log(chalk.yellow("Migration guides not found, using embedded guidance"));
      }
    }
    console.log(chalk.green("\u2705 Environment ready"));
    console.log(chalk.bold("\nElizaOS Plugin Migration (0.x \u2192 1.x)"));
    console.log(chalk.gray("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
    console.log("\u2022 Enhanced AI-powered migration with comprehensive guide integration");
    console.log("\u2022 9-gate progressive validation system with RAG search");
    console.log("\u2022 Automated analysis and migration with 95%+ test coverage");
    console.log("\u2022 Zero-failure release preparation with full validation");
    if (opts.debug) {
      console.log(chalk.gray(`
Plugin: ${pluginPath}`));
      console.log(chalk.gray(`Working directory: ${workingDir}`));
    }
    if (!opts.skipConfirmation) {
      console.log(chalk.yellow("\n\u26A0\uFE0F  This will modify files in the plugin directory."));
      console.log(chalk.yellow("Ensure your changes are committed first.\n"));
      console.log("Starting in 3 seconds... (Press Ctrl+C to cancel)");
      await new Promise((resolve2) => setTimeout(resolve2, 3e3));
    }
    const agent2 = new SimpleMigrationAgent(workingDir, {
      verbose: opts.verbose || opts.debug
    });
    let messageCount = 0;
    agent2.on("progress", (count) => {
      messageCount = count;
    });
    const result = await agent2.migrate();
    try {
      if (existsSync11(guidesTarget)) {
        await fs.remove(guidesTarget);
        if (opts.debug) {
          console.log(chalk.gray("Cleaned up migration guides"));
        }
      }
    } catch (cleanupError) {
      if (opts.debug) {
        console.log(chalk.yellow(`Warning: Could not clean up guides: ${cleanupError}`));
      }
    }
    if (result.success) {
      console.log(chalk.green("\nMigration completed successfully!"));
      console.log(chalk.gray("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
      console.log(`Location: ${chalk.cyan(path12.basename(result.repoPath))}`);
      console.log(`Duration: ${chalk.yellow(Math.round(result.duration / 1e3) + "s")}`);
      console.log(`AI Operations: ${chalk.blue(result.messageCount)}`);
      if (result.guidesUsed && result.guidesUsed.length > 0) {
        console.log(`Migration Guides Used: ${chalk.magenta(result.guidesUsed.length)}`);
        if (opts.debug) {
          console.log(`  ${chalk.gray(result.guidesUsed.join(", "))}`);
        }
      }
      console.log(chalk.bold("\nNext Steps:"));
      console.log(`${chalk.gray("1.")} cd ${chalk.cyan(path12.basename(result.repoPath))}`);
      console.log(
        `${chalk.gray("2.")} git checkout 1.x ${chalk.gray("# Review the migrated code")}`
      );
      console.log(`${chalk.gray("3.")} bun test ${chalk.gray("# Verify all tests pass")}`);
      console.log(`${chalk.gray("4.")} bun run build ${chalk.gray("# Verify the build")}`);
      console.log(`${chalk.gray("5.")} Test in a real project`);
      console.log(`${chalk.gray("6.")} Merge to main and publish
`);
    } else {
      console.log(chalk.red("\n\u274C Migration failed"));
      console.log(chalk.gray("\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"));
      if (result.error) {
        const errorMsg = result.error.message || String(result.error);
        console.log(chalk.red(`\u{1F4A5} ${errorMsg}`));
        if (opts.debug || opts.verbose) {
          console.log(chalk.gray("\nDetailed error:"));
          console.log(chalk.gray(result.error.stack || result.error.message));
        }
      }
      console.log(chalk.yellow("\n\u{1F527} Quick fixes:"));
      console.log("\u2022 Check plugin structure follows ElizaOS standards");
      console.log("\u2022 Verify ANTHROPIC_API_KEY is valid");
      console.log("\u2022 Try with --debug for detailed output");
      console.log("\u2022 Ensure all dependencies are installed\n");
      process.exit(1);
    }
  } catch (error) {
    try {
      const guidesTarget = path12.join(path12.resolve(pluginPath), "migration-guides");
      if (existsSync11(guidesTarget)) {
        await fs.remove(guidesTarget);
        if (opts.debug) {
          console.log(chalk.gray("Cleaned up migration guides after error"));
        }
      }
    } catch (cleanupError) {
    }
    console.log("\n" + chalk.red("\u2717 Plugin upgrade failed!"));
    if (opts.debug || opts.verbose) {
      console.log("\n" + chalk.bold("Detailed Error Information:"));
      console.log(chalk.red(error instanceof Error ? error.stack : String(error)));
    } else {
      console.log(chalk.red(`
Error: ${error instanceof Error ? error.message : String(error)}`));
    }
    console.log("\n" + chalk.yellow("Troubleshooting Tips:"));
    console.log("1. Check that your plugin follows standard ElizaOS structure");
    console.log("2. Ensure all dependencies are installed");
    console.log("3. Try running with --verbose or --debug for more details");
    console.log("4. Verify your ANTHROPIC_API_KEY is valid");
    handleError(error);
    process.exit(1);
  }
}

// src/commands/plugins/actions/generate.ts
import { logger as logger10 } from "@elizaos/core";
import { readFileSync as readFileSync4 } from "fs";
import path13 from "path";
async function generatePlugin(opts) {
  try {
    const { PluginCreator } = await import("./plugin-creator-H26ZLR6H.js");
    if (opts.apiKey) {
      process.env.ANTHROPIC_API_KEY = opts.apiKey;
    }
    if (!process.env.ANTHROPIC_API_KEY) {
      logger10.error("ANTHROPIC_API_KEY is required for plugin generation.");
      console.log("\nPlease set ANTHROPIC_API_KEY environment variable or use --api-key option.");
      process.exit(1);
    }
    let spec = void 0;
    if (opts.specFile) {
      try {
        const specContent = readFileSync4(opts.specFile, "utf-8");
        spec = JSON.parse(specContent);
      } catch (error) {
        logger10.error(
          `Failed to read or parse spec file: ${error instanceof Error ? error.message : String(error)}`
        );
        process.exit(1);
      }
    } else if (opts.skipPrompts) {
      logger10.error("--skip-prompts requires --spec-file to be provided");
      process.exit(1);
    }
    const creator = new PluginCreator({
      skipTests: opts.skipTests,
      skipValidation: opts.skipValidation,
      skipPrompts: opts.skipPrompts,
      spec
    });
    console.log(`
${emoji.rocket("Starting AI-powered plugin generation...")}
`);
    const result = await creator.create();
    if (result.success) {
      console.log(`
${emoji.success("Plugin successfully generated!")}`);
      console.log(`   Name: ${result.pluginName}`);
      console.log(`   Location: ${result.pluginPath}`);
      console.log(`
The plugin has been created in your current directory.`);
      console.log(`
Next steps:`);
      console.log(`1. cd ${path13.basename(result.pluginPath ?? "")}`);
      console.log(`2. Review the generated code`);
      console.log(`3. Test the plugin: bun test`);
      console.log(`4. Add to your ElizaOS project`);
    } else {
      logger10.error(`Plugin generation failed: ${result.error?.message}`);
      process.exit(1);
    }
  } catch (error) {
    handleError(error);
    process.exit(1);
  }
}

// src/commands/plugins/index.ts
var plugins = new Command3().name("plugins").description("Manage ElizaOS plugins").action(() => {
  plugins.help();
});
var pluginsCommand = plugins.command("list").aliases(["l", "ls"]).description("List available plugins to install into the project (shows v1.x plugins by default)").option("--all", "List all plugins from the registry with detailed version info").option("--v0", "List only v0.x compatible plugins").action(async (opts) => {
  try {
    await listAvailablePlugins(opts);
  } catch (error) {
    handleError(error);
  }
});
plugins.command("add").alias("install").description("Add a plugin to the project").argument("<plugin>", 'plugin name (e.g., "abc", "plugin-abc", "elizaos/plugin-abc")').option("-s, --skip-env-prompt", "Skip prompting for environment variables").option("--skip-verification", "Skip plugin import verification after installation").option("-b, --branch <branchName>", "Branch to install from when using monorepo source", "main").option("-T, --tag <tagname>", "Specify a tag to install (e.g., beta)").action(async (pluginArg, opts) => {
  try {
    await addPlugin(pluginArg, opts);
  } catch (error) {
    handleError(error);
  }
});
plugins.command("installed-plugins").description("List plugins found in the project dependencies").action(async () => {
  try {
    await listInstalledPlugins();
  } catch (error) {
    if (error instanceof SyntaxError) {
      console.error(`Error parsing package.json: ${error.message}`);
      process.exit(1);
    }
    handleError(error);
    process.exit(1);
  }
});
plugins.command("remove").aliases(["delete", "del", "rm"]).description("Remove a plugin from the project").argument("<plugin>", 'plugins name (e.g., "abc", "plugin-abc", "elizaos/plugin-abc")').action(async (plugin, _opts) => {
  try {
    await removePlugin(plugin);
  } catch (error) {
    handleError(error);
    process.exit(1);
  }
});
plugins.command("upgrade").description(
  "Upgrade a plugin from version 0.x to 1.x using AI-powered migration (requires Claude Code CLI)"
).argument("<path>", "GitHub repository URL or local folder path").option("--api-key <key>", "Anthropic API key (or use ANTHROPIC_API_KEY env var)").option("--skip-tests", "Skip test validation loop").option("--skip-validation", "Skip production readiness validation").option("--quiet", "Suppress progress display").option("--verbose", "Show detailed information").option("--debug", "Show debug information").option("--skip-confirmation", "Skip user confirmation").action(async (pluginPath, opts) => {
  await upgradePlugin(pluginPath, opts);
});
plugins.command("generate").description("Generate a new plugin using AI-powered code generation").option("--api-key <key>", "Anthropic API key (or use ANTHROPIC_API_KEY env var)").option("--skip-tests", "Skip test validation loop").option("--skip-validation", "Skip production readiness validation").option("--skip-prompts", "Skip interactive prompts (requires --spec-file)").option("--spec-file <path>", "Path to JSON file containing plugin specification").action(async (opts) => {
  await generatePlugin(opts);
});

// src/commands/publish/index.ts
import { Command as Command5 } from "commander";
import { promises as fs8 } from "fs";
import path19 from "path";
import * as clack10 from "@clack/prompts";

// src/commands/publish/actions/npm-publish.ts
import { promises as fs2 } from "fs";
import path14 from "path";
async function publishToNpm(cwd, packageJson, npmUsername) {
  console.info(`Publishing as npm user: ${npmUsername}`);
  if (!packageJson.npmPackage || packageJson.npmPackage === "${NPM_PACKAGE}") {
    packageJson.npmPackage = packageJson.name;
    console.info(`Set npmPackage to: ${packageJson.npmPackage}`);
    const packageJsonPath = path14.join(cwd, "package.json");
    await fs2.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
  }
  console.info("Building package...");
  await bunExecInherit("npm", ["run", "build"], { cwd });
  console.info("Publishing to npm...");
  await bunExecInherit("npm", ["publish", "--ignore-scripts"], { cwd });
  console.log(`[\u221A] Successfully published ${packageJson.name}@${packageJson.version} to npm`);
}

// src/commands/publish/actions/github-publish.ts
async function publishToGitHubAction(cwd, packageJson, credentials, skipRegistry = false, dryRun = false) {
  console.info("Publishing to GitHub and registry...");
  const result = await publishToGitHub(
    cwd,
    packageJson,
    credentials.username,
    skipRegistry,
    dryRun
  );
  if (!result) {
    throw new Error("GitHub publishing failed");
  }
  console.log(
    `[\u221A] Successfully published plugin ${packageJson.name}@${packageJson.version} to GitHub`
  );
  return result;
}

// src/commands/publish/actions/registry-publish.ts
import { promises as fs3 } from "fs";
import path15 from "path";
var REGISTRY_PACKAGES_PATH = "packages";
var LOCAL_REGISTRY_PATH = "packages/registry";
async function updateRegistryIndex(packageMetadata, dryRun = false) {
  try {
    const indexPath = dryRun ? path15.join(process.cwd(), LOCAL_REGISTRY_PATH, "index.json") : path15.join(process.cwd(), "temp-registry", "index.json");
    try {
      await fs3.access(path15.dirname(indexPath));
    } catch {
      await fs3.mkdir(path15.dirname(indexPath), { recursive: true });
      try {
        await fs3.access(indexPath);
      } catch {
        await fs3.writeFile(
          indexPath,
          JSON.stringify(
            {
              v1: { packages: {} },
              v2: { packages: {} }
            },
            null,
            2
          )
        );
      }
    }
    let indexContent;
    try {
      indexContent = await fs3.readFile(indexPath, "utf-8");
    } catch (error) {
      indexContent = JSON.stringify({
        v1: { packages: {} },
        v2: { packages: {} }
      });
    }
    const index = JSON.parse(indexContent);
    if (!index.v2) {
      index.v2 = { packages: {} };
    }
    if (!index.v2.packages) {
      index.v2.packages = {};
    }
    if (!index.v2.packages[packageMetadata.name]) {
      index.v2.packages[packageMetadata.name] = {
        name: packageMetadata.name,
        description: packageMetadata.description,
        type: packageMetadata.type,
        versions: {}
      };
    }
    const packageInfo = index.v2.packages[packageMetadata.name];
    packageInfo.description = packageMetadata.description;
    packageInfo.type = packageMetadata.type;
    packageInfo.versions[packageMetadata.version] = {
      version: packageMetadata.version,
      runtimeVersion: packageMetadata.runtimeVersion,
      platform: packageMetadata.platform,
      publishedAt: packageMetadata.publishedAt,
      published: !dryRun
    };
    await fs3.writeFile(indexPath, JSON.stringify(index, null, 2));
    console.info(
      `Registry index ${dryRun ? "(dry run) " : ""}updated with ${packageMetadata.name}@${packageMetadata.version}`
    );
    return true;
  } catch (error) {
    console.error(
      `Failed to update registry index: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }
}
async function savePackageToRegistry(packageMetadata, dryRun = false) {
  try {
    const packageDir = dryRun ? path15.join(process.cwd(), LOCAL_REGISTRY_PATH, REGISTRY_PACKAGES_PATH, packageMetadata.name) : path15.join(process.cwd(), "temp-registry", REGISTRY_PACKAGES_PATH, packageMetadata.name);
    const metadataPath = path15.join(packageDir, `${packageMetadata.version}.json`);
    await fs3.mkdir(packageDir, { recursive: true });
    await fs3.writeFile(metadataPath, JSON.stringify(packageMetadata, null, 2));
    console.info(`Package metadata ${dryRun ? "(dry run) " : ""}saved to ${metadataPath}`);
    await updateRegistryIndex(packageMetadata, dryRun);
    return true;
  } catch (error) {
    console.error(
      `Failed to save package metadata: ${error instanceof Error ? error.message : String(error)}`
    );
    return false;
  }
}

// src/commands/publish/utils/validation.ts
import { promises as fs4 } from "fs";
import path16 from "path";
import * as clack6 from "@clack/prompts";
async function validatePluginRequirements(cwd, packageJson) {
  const errors = [];
  const warnings = [];
  const packageName = packageJson.name.split("/").pop() || packageJson.name;
  if (!packageName.startsWith("plugin-")) {
    errors.push(
      'Plugin name must start with "plugin-". Please update your package name and try again.'
    );
  }
  const pluginDirName = path16.basename(cwd);
  const expectedDefaultDesc = `ElizaOS plugin for ${pluginDirName.replace("plugin-", "")}`;
  if (packageJson.description === expectedDefaultDesc || packageJson.description === "${PLUGINDESCRIPTION}") {
    warnings.push(
      "Description appears to be the default generated description. Consider writing a custom description."
    );
  }
  const imagesDir = path16.join(cwd, "images");
  const logoPath = path16.join(imagesDir, "logo.jpg");
  const bannerPath = path16.join(imagesDir, "banner.jpg");
  try {
    await fs4.access(logoPath);
  } catch {
    warnings.push("Missing required logo.jpg in images/ directory (400x400px, max 500KB).");
  }
  try {
    await fs4.access(bannerPath);
  } catch {
    warnings.push("Missing required banner.jpg in images/ directory (1280x640px, max 1MB).");
  }
  if (errors.length > 0) {
    console.error("Plugin validation failed:");
    errors.forEach((error) => console.error(`  - ${error}`));
    console.error("\nPlease fix these issues and try publishing again.");
    process.exit(1);
  }
  if (warnings.length > 0) {
    console.warn("Plugin validation warnings:");
    warnings.forEach((warning) => console.warn(`  - ${warning}`));
    console.warn("Your plugin may get rejected if you submit without addressing these issues.");
    const proceed = await clack6.confirm({
      message: "Do you wish to continue anyway?",
      initialValue: false
    });
    if (clack6.isCancel(proceed)) {
      clack6.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!proceed) {
      console.info("Publishing cancelled. Please address the warnings and try again.");
      process.exit(0);
    }
  }
}
function isMaintainer(packageJson, username) {
  if (!packageJson.maintainers) {
    return true;
  }
  return packageJson.maintainers.includes(username);
}
function displayRegistryPublicationMessage(opts, userIsMaintainer, registryPrUrl) {
  if (opts.skipRegistry) {
    console.info("Registry publication skipped as requested with --skip-registry flag");
    return;
  }
  if (opts.npm) {
    console.warn("NPM publishing currently does not update the registry.");
    console.info("To include this package in the registry:");
    console.info(`1. Fork the registry repository at https://github.com/elizaos/registry`);
    console.info("2. Add your package metadata");
    console.info("3. Submit a pull request to the main repository");
    return;
  }
  if (userIsMaintainer) {
    if (!registryPrUrl) {
      console.info("Registry publication completed during GitHub publishing process.");
    }
  } else {
    console.info("Package published, but you're not a maintainer of this package.");
    console.info("To include this package in the registry, please:");
    console.info(`1. Fork the registry repository at https://github.com/elizaos/registry`);
    console.info("2. Add your package metadata");
    console.info("3. Submit a pull request to the main repository");
  }
}

// src/commands/publish/utils/metadata.ts
async function generatePackageMetadata(packageJson, cliVersion, username) {
  const metadata = {
    name: packageJson.name,
    version: packageJson.version,
    description: packageJson.description || "",
    type: packageJson.type || "plugin",
    // plugin or project
    platform: packageJson.platform || "universal",
    // node, browser, or universal
    runtimeVersion: cliVersion,
    // Compatible CLI/runtime version
    repository: packageJson.repository?.url || "",
    maintainers: packageJson.maintainers || [username],
    publishedAt: (/* @__PURE__ */ new Date()).toISOString(),
    publishedBy: username,
    dependencies: packageJson.dependencies || {},
    tags: packageJson.keywords || [],
    license: packageJson.license || "UNLICENSED"
  };
  if (packageJson.npmPackage) {
    metadata.npmPackage = packageJson.npmPackage;
  }
  if (packageJson.githubRepo) {
    metadata.githubRepo = packageJson.githubRepo;
  }
  if (metadata.type === "plugin" && !metadata.tags.includes("plugin")) {
    metadata.tags.push("plugin");
  } else if (metadata.type === "project" && !metadata.tags.includes("project")) {
    metadata.tags.push("project");
  }
  return metadata;
}

// src/commands/publish/utils/authentication.ts
import * as clack7 from "@clack/prompts";
async function getNpmUsername() {
  console.info(
    "NPM authentication required for registry compliance (package name must match potential NPM package)."
  );
  try {
    const { stdout } = await bunExecSimple("npm", ["whoami"]);
    const currentUser = stdout.trim();
    console.info(`Found existing NPM login: ${currentUser}`);
    const useExisting = await clack7.confirm({
      message: `Use NPM account "${currentUser}" for package naming?`,
      initialValue: true
    });
    if (clack7.isCancel(useExisting)) {
      clack7.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (useExisting) {
      return currentUser;
    } else {
      console.info("Please login with your desired NPM account...");
      await bunExecInherit("npm", ["login"]);
      const { stdout: newStdout } = await bunExecSimple("npm", ["whoami"]);
      const newUser = newStdout.trim();
      console.info(`Logged in as: ${newUser}`);
      return newUser;
    }
  } catch (error) {
    console.info("Not logged into NPM. Please login to continue...");
    try {
      await bunExecInherit("npm", ["login"]);
      const { stdout } = await bunExecSimple("npm", ["whoami"]);
      const username = stdout.trim();
      console.info(`Successfully logged in as: ${username}`);
      return username;
    } catch (loginError) {
      console.error("NPM login failed. Registry compliance requires a valid NPM account.");
      process.exit(1);
    }
  }
}

// src/commands/publish/utils/version-check.ts
import { promises as fs7 } from "fs";
import path18 from "path";
import { fileURLToPath as fileURLToPath3 } from "url";
import * as clack9 from "@clack/prompts";

// src/commands/update/index.ts
import { logger as logger14 } from "@elizaos/core";
import { Command as Command4 } from "commander";

// src/commands/update/actions/cli-update.ts
import { logger as logger12 } from "@elizaos/core";

// src/commands/update/utils/version-utils.ts
import { logger as logger11 } from "@elizaos/core";
import * as semver from "semver";
var SPECIAL_VERSION_TAGS = ["latest", "next", "canary", "rc", "dev", "nightly", "alpha"];
var ELIZAOS_ORG = "@elizaos";
var FALLBACK_VERSION = "0.0.0";
async function getVersion2() {
  try {
    const envInfo = await UserEnvironment.getInstance().getInfo();
    return envInfo.cli.version;
  } catch (error) {
    logger11.error("Error getting CLI version:", error);
    return FALLBACK_VERSION;
  }
}
var isWorkspaceVersion = (version) => version === "workspace:*" || version === "workspace" || version.startsWith("workspace:");
var isSpecialVersionTag = (version) => SPECIAL_VERSION_TAGS.includes(version);
function checkVersionNeedsUpdate(currentVersion, targetVersion) {
  try {
    const cleanCurrent = String(currentVersion).replace(/^[\^~]/, "");
    if (isSpecialVersionTag(cleanCurrent)) {
      return { needsUpdate: true };
    }
    if (!semver.valid(cleanCurrent) && !semver.validRange(cleanCurrent)) {
      return { needsUpdate: false, error: "Invalid semver format" };
    }
    const versionToCompare = semver.validRange(cleanCurrent) ? semver.minVersion(cleanCurrent)?.version || cleanCurrent : cleanCurrent;
    return { needsUpdate: semver.lt(versionToCompare, targetVersion) };
  } catch (error) {
    return { needsUpdate: false, error: error instanceof Error ? error.message : String(error) };
  }
}
function isMajorUpdate(currentVersion, targetVersion) {
  try {
    const cleanCurrent = String(currentVersion).replace(/^[\^~]/, "");
    if (isSpecialVersionTag(cleanCurrent) || !semver.valid(cleanCurrent)) {
      return false;
    }
    const currentMajor = semver.major(cleanCurrent);
    const targetMajor = semver.major(targetVersion);
    return targetMajor > currentMajor;
  } catch {
    return false;
  }
}
async function fetchLatestVersion(packageName) {
  try {
    const { stdout } = await bunExecSimple("npm", ["view", packageName, "version"], {
      env: { NODE_ENV: "production" }
    });
    const version = stdout.trim();
    logger11.debug(`Latest version of ${packageName} from npm: ${version}`);
    return version;
  } catch (error) {
    logger11.error(
      `Failed to fetch version for ${packageName}: ${error instanceof Error ? error.message : String(error)}`
    );
    return null;
  }
}

// src/commands/update/actions/cli-update.ts
async function performCliUpdate(options = {}) {
  try {
    const currentVersion = await getVersion2();
    const targetVersion = options.version || "latest";
    let latestVersion;
    if (targetVersion === "latest") {
      const fetchedVersion = await fetchLatestVersion("@elizaos/cli");
      if (!fetchedVersion) {
        throw new Error("Unable to fetch latest CLI version");
      }
      latestVersion = fetchedVersion;
    } else {
      latestVersion = targetVersion;
    }
    const { needsUpdate } = checkVersionNeedsUpdate(currentVersion, latestVersion);
    if (!needsUpdate) {
      console.log(`CLI is already at the latest version (${currentVersion}) [\u2713]`);
      return true;
    }
    console.log(`Updating CLI from ${currentVersion} to ${latestVersion}...`);
    if (!options.skipBunMigration) {
      const npmInstallation = await isCliInstalledViaNpm();
      if (npmInstallation) {
        logger12.info("Detected npm installation, migrating to bun...");
        try {
          await migrateCliToBun(latestVersion);
          console.log(`CLI updated successfully to version ${latestVersion} [\u2713]`);
          return true;
        } catch (migrationError) {
          logger12.warn("Migration to bun failed, falling back to npm update...");
          logger12.debug(
            "Migration error:",
            migrationError instanceof Error ? migrationError.message : String(migrationError)
          );
          try {
            await bunExecInherit("npm", ["install", "-g", `@elizaos/cli@${latestVersion}`]);
            console.log(`CLI updated successfully to version ${latestVersion} [\u2713]`);
            return true;
          } catch (npmError) {
            throw new Error(
              `Both bun migration and npm fallback failed. Bun: ${migrationError instanceof Error ? migrationError.message : String(migrationError)}, npm: ${npmError instanceof Error ? npmError.message : String(npmError)}`
            );
          }
        }
      }
    }
    try {
      await bunExecInherit("bun", ["add", "-g", `@elizaos/cli@${latestVersion}`]);
      console.log(`CLI updated successfully to version ${latestVersion} [\u2713]`);
      return true;
    } catch (bunError) {
      console.error("Bun installation not found. Please install bun first:");
      console.error("  curl -fsSL https://bun.sh/install | bash");
      console.error("  # or");
      console.error("  npm install -g bun");
      logger12.debug("Bun error:", bunError instanceof Error ? bunError.message : String(bunError));
      return false;
    }
  } catch (error) {
    console.error(`CLI update failed: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// src/commands/update/actions/dependency-update.ts
import * as clack8 from "@clack/prompts";
import { promises as fs6 } from "fs";
import * as path17 from "path";

// src/commands/update/utils/package-utils.ts
import fs5 from "fs/promises";
import { logger as logger13 } from "@elizaos/core";
async function checkForUpdates(dependencies) {
  const updates = {};
  const elizaPackages = Object.entries(dependencies).filter(([pkg]) => pkg.startsWith(ELIZAOS_ORG)).filter(([, version]) => !isWorkspaceVersion(version));
  for (const [pkg, currentVersion] of elizaPackages) {
    const latestVersion = await fetchLatestVersion(pkg);
    if (!latestVersion) continue;
    const { needsUpdate, error } = checkVersionNeedsUpdate(currentVersion, latestVersion);
    if (needsUpdate) {
      updates[pkg] = { current: currentVersion, latest: latestVersion };
    } else if (error) {
      logger13.debug(`${pkg}: ${error}`);
    }
  }
  return { hasUpdates: Object.keys(updates).length > 0, updates };
}
function displayUpdateSummary(updates) {
  console.log("\nAvailable updates:");
  Object.entries(updates).forEach(([pkg, { current, latest }]) => {
    const majorUpdate = isMajorUpdate(current, latest);
    const updateType = majorUpdate ? " (MAJOR)" : "";
    console.log(`  ${pkg}: ${current} \u2192 ${latest}${updateType}`);
  });
}
async function updatePackageJson(packageJsonPath, updates) {
  const content = await fs5.readFile(packageJsonPath, "utf8");
  const packageJson = JSON.parse(content);
  let modified = false;
  for (const [pkg, { latest }] of Object.entries(updates)) {
    if (packageJson.dependencies?.[pkg]) {
      packageJson.dependencies[pkg] = `^${latest}`;
      modified = true;
    }
    if (packageJson.devDependencies?.[pkg]) {
      packageJson.devDependencies[pkg] = `^${latest}`;
      modified = true;
    }
  }
  if (modified) {
    await fs5.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2) + "\n");
    console.log("Updated package.json with new versions");
  }
}
async function installDependencies(cwd) {
  console.log("\nInstalling updated packages...");
  try {
    const packageManager = await getPackageManager();
    await bunExecInherit(packageManager, ["install"], { cwd });
    console.log("Dependencies installed successfully [\u2713]");
  } catch (error) {
    throw new Error(
      `Failed to install dependencies: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

// src/commands/update/actions/dependency-update.ts
async function updateDependencies(cwd, isPlugin2, options = {}) {
  const { dryRun = false, skipBuild = false } = options;
  const packageJsonPath = path17.join(cwd, "package.json");
  const content = await fs6.readFile(packageJsonPath, "utf8");
  const packageJson = JSON.parse(content);
  const allDependencies = {
    ...packageJson.dependencies,
    ...packageJson.devDependencies
  };
  const { hasUpdates, updates } = await checkForUpdates(allDependencies);
  if (!hasUpdates) {
    console.log("All ElizaOS packages are up to date! [\u2713]");
    return;
  }
  displayUpdateSummary(updates);
  if (dryRun) {
    console.log("\nTo apply these updates, run: elizaos update");
    return;
  }
  const hasMajorUpdates = Object.entries(updates).some(
    ([, { current, latest }]) => isMajorUpdate(current, latest)
  );
  if (hasMajorUpdates) {
    const confirmMajor = await clack8.confirm({
      message: "This update includes major version changes. Continue?",
      initialValue: false
    });
    if (clack8.isCancel(confirmMajor)) {
      clack8.cancel("Operation cancelled.");
      process.exit(0);
    }
    if (!confirmMajor) {
      console.log("Update cancelled");
      return;
    }
  }
  await updatePackageJson(packageJsonPath, updates);
  await installDependencies(cwd);
  if (!skipBuild) {
    console.log("\nBuilding project...");
    await buildProject(cwd, isPlugin2);
    console.log("Build completed successfully [\u2713]");
  }
}

// src/commands/update/utils/directory-utils.ts
function handleInvalidDirectory(directoryInfo) {
  const messages = {
    "non-elizaos-dir": [
      "This directory doesn't appear to be an ElizaOS project.",
      directoryInfo.packageName && `Found package: ${directoryInfo.packageName}`,
      "ElizaOS update only works in ElizaOS projects, plugins, the ElizaOS monorepo, and ElizaOS infrastructure packages (e.g. client, cli).",
      "To create a new ElizaOS project, use: elizaos create <project-name>"
    ].filter(Boolean),
    invalid: [
      "Cannot update packages in this directory.",
      !directoryInfo.hasPackageJson ? "No package.json found. This doesn't appear to be a valid project directory." : "The package.json file appears to be invalid or unreadable.",
      "To create a new ElizaOS project, use: elizaos create <project-name>"
    ].filter(Boolean)
  };
  const messageList = messages[directoryInfo.type];
  if (messageList) {
    messageList.forEach((msg) => console.info(msg));
  } else {
    console.error(`Unexpected directory type: ${directoryInfo.type}`);
  }
}

// src/commands/update/index.ts
var update = new Command4().name("update").description("Update ElizaOS CLI and project dependencies").option("-c, --check", "Check for available updates without applying them").option("--skip-build", "Skip building after updating").option("--cli", "Update only the CLI").option("--packages", "Update only packages").hook("preAction", async () => {
  try {
    await displayBanner(true);
  } catch {
    logger14.debug("Banner display failed, continuing with update");
  }
}).action(async (options) => {
  try {
    const cwd = process.cwd();
    const directoryInfo = detectDirectoryType(cwd);
    const isInProject = directoryInfo && isValidForUpdates(directoryInfo);
    const updateCli = options.cli || !options.cli && !options.packages;
    const updatePackages = options.packages || !options.cli && !options.packages && isInProject;
    if (updateCli) {
      const isNpx = await isRunningViaNpx();
      const isBunx = await isRunningViaBunx();
      if (isNpx || isBunx) {
        console.warn("CLI update is not available when running via npx or bunx.");
        console.info("Please install the CLI globally:");
        console.info(" bun install -g @elizaos/cli");
        if (!updatePackages) return;
      } else {
        const success = await performCliUpdate();
        if (!updatePackages) return;
        if (!success) {
          console.warn("CLI update failed, continuing with package updates...");
        }
      }
    }
    if (updatePackages) {
      if (!directoryInfo) {
        console.error("Cannot update packages in this directory.");
        console.info("This directory is not accessible or does not exist.");
        console.info("To create a new ElizaOS project, use: elizaos create <project-name>");
        return;
      }
      logger14.debug(`Detected ${directoryInfo.type}`);
      if (!isInProject) {
        handleInvalidDirectory(directoryInfo);
        return;
      }
      const isPlugin2 = directoryInfo.type === "elizaos-plugin";
      if (directoryInfo.elizaPackageCount === 0) {
        console.info("No ElizaOS packages found in this project.");
        console.info(
          "This might be a new project that hasn't installed ElizaOS dependencies yet."
        );
        console.info("Consider adding ElizaOS packages first, such as: bun add @elizaos/core");
        return;
      }
      console.info(
        `Found ${directoryInfo.elizaPackageCount} ElizaOS package(s) to check for updates`
      );
      const updateOptions = {
        dryRun: options.check,
        skipBuild: options.skipBuild
      };
      await updateDependencies(cwd, isPlugin2, updateOptions);
      if (options.check) {
        console.log(`Version: ${await getVersion2()}`);
      } else {
        const projectType = isPlugin2 ? "Plugin" : "Project";
        console.log(`${projectType} successfully updated to the latest ElizaOS packages`);
      }
    }
  } catch (error) {
    handleError(error);
  }
});

// src/commands/publish/utils/version-check.ts
async function checkCliVersion() {
  try {
    const cliPackageJsonPath = path18.resolve(
      path18.dirname(fileURLToPath3(import.meta.url)),
      "../package.json"
    );
    const cliPackageJsonContent = await fs7.readFile(cliPackageJsonPath, "utf-8");
    const cliPackageJson = JSON.parse(cliPackageJsonContent);
    const currentVersion = cliPackageJson.version || "0.0.0";
    const { stdout } = await bunExecSimple("npm", ["view", "@elizaos/cli", "time", "--json"]);
    const timeData = JSON.parse(stdout);
    delete timeData.created;
    delete timeData.modified;
    let latestVersion = "";
    let latestDate = /* @__PURE__ */ new Date(0);
    for (const [version, dateString] of Object.entries(timeData)) {
      const publishDate = new Date(dateString);
      if (publishDate > latestDate) {
        latestDate = publishDate;
        latestVersion = version;
      }
    }
    if (latestVersion && latestVersion !== currentVersion) {
      console.warn(`CLI update available: ${currentVersion} \u2192 ${latestVersion}`);
      const update2 = await clack9.confirm({
        message: "Update CLI before publishing?",
        initialValue: false
      });
      if (clack9.isCancel(update2)) {
        clack9.cancel("Operation cancelled.");
        process.exit(0);
      }
      if (update2) {
        console.info("Updating CLI...");
        try {
          await performCliUpdate();
          process.exit(0);
        } catch (updateError) {
          console.error("Failed to update CLI:", updateError);
        }
      }
    }
    return currentVersion;
  } catch (error) {
    console.warn("Could not check for CLI updates");
    return "0.0.0";
  }
}

// src/commands/publish/index.ts
var LOCAL_REGISTRY_PATH2 = "packages/registry";
var publish = new Command5().name("publish").description("Publish a plugin to npm, GitHub, and the registry").option("--npm", "publish to npm only (skip GitHub and registry)", false).option("-t, --test", "test publish process without making changes", false).option("-d, --dry-run", "generate registry files locally without publishing", false).option("--skip-registry", "skip publishing to the registry", false).hook("preAction", async () => {
  await displayBanner();
}).action(async (opts) => {
  try {
    const cwd = process.cwd();
    const directoryInfo = detectDirectoryType(cwd);
    if (!directoryInfo || !directoryInfo.hasPackageJson) {
      console.error(
        `No package.json found in current directory. This directory is: ${directoryInfo?.type || "invalid or inaccessible"}`
      );
      process.exit(1);
    }
    const cliVersion = await checkCliVersion();
    const pluginDirName = path19.basename(process.cwd());
    if (!pluginDirName.startsWith("plugin-")) {
      console.error("This command must be run from a plugin directory (plugin-*)");
      process.exit(1);
    }
    if (!opts.npm) {
      const isValid = await validateDataDir();
      if (!isValid) {
        console.info("\nGitHub credentials required for publishing.");
        console.info("You'll need a GitHub Personal Access Token with these scopes:");
        console.info("  * repo (for repository access)");
        console.info("  * read:org (for organization access)");
        console.info("  * workflow (for workflow access)\n");
        await initializeDataDir();
        const credentials2 = await getGitHubCredentials();
        if (!credentials2) {
          console.error("GitHub credentials setup cancelled.");
          process.exit(1);
        }
        const revalidated = await validateDataDir();
        if (!revalidated) {
          console.error("Failed to validate credentials after saving.");
          process.exit(1);
        }
      }
    }
    const packageJsonPath = path19.join(cwd, "package.json");
    const packageJsonContent = await fs8.readFile(packageJsonPath, "utf-8");
    const packageJson = JSON.parse(packageJsonContent);
    if (!packageJson.name || !packageJson.version) {
      console.error("Invalid package.json: missing name or version.");
      process.exit(1);
    }
    let detectedType;
    if (directoryInfo.type === "elizaos-plugin") {
      detectedType = "plugin";
      console.info("Detected ElizaOS plugin using standardized directory detection");
    } else if (directoryInfo.type === "elizaos-project") {
      detectedType = "project";
      console.info("Detected ElizaOS project using standardized directory detection");
    } else {
      detectedType = "plugin";
      if (packageJson.agentConfig?.pluginType) {
        const pluginType = packageJson.agentConfig.pluginType.toLowerCase();
        if (pluginType.includes("project")) {
          detectedType = "project";
          console.info("Detected project from package.json agentConfig.pluginType");
        }
      } else if (packageJson.eliza?.type === "project") {
        detectedType = "project";
        console.info("Detected project from package.json eliza.type (legacy format)");
      } else if (packageJson.packageType === "project") {
        detectedType = "project";
        console.info("Detected project from package.json packageType field");
      } else {
        console.info(`Defaulting to plugin type. Directory detected as: ${directoryInfo.type}`);
      }
    }
    packageJson.packageType = detectedType;
    packageJson.platform ??= "node";
    if (!packageJson.agentConfig) {
      packageJson.agentConfig = {
        pluginType: detectedType === "plugin" ? "elizaos:plugin:1.0.0" : "elizaos:project:1.0.0",
        pluginParameters: {}
      };
    } else if (!packageJson.agentConfig.pluginType) {
      packageJson.agentConfig.pluginType = detectedType === "plugin" ? "elizaos:plugin:1.0.0" : "elizaos:project:1.0.0";
    }
    if (detectedType === "plugin" && !packageJson.name.includes("plugin-")) {
      console.warn(
        "This doesn't appear to be an ElizaOS plugin. Package name should include 'plugin-'."
      );
      const proceed = await clack10.confirm({
        message: "Proceed anyway?",
        initialValue: false
      });
      if (clack10.isCancel(proceed)) {
        clack10.cancel("Operation cancelled.");
        process.exit(0);
      }
      if (!proceed) {
        process.exit(0);
      }
    }
    let credentials = null;
    if (!opts.npm) {
      credentials = await getGitHubCredentials();
      if (!credentials) {
        console.error("GitHub credentials required for publishing.");
        process.exit(1);
      }
    }
    const npmUsername = await getNpmUsername();
    console.info(`Using NPM username: ${npmUsername}`);
    console.info("Updating package.json with actual values...");
    const placeholderReplacements = {
      // Template default name replacement
      "elizaos-plugin-starter": {
        check: () => packageJson.name === "@elizaos/plugin-starter",
        replace: () => {
          packageJson.name = `@${npmUsername}/${pluginDirName}`;
          console.info(`Set package name: ${packageJson.name}`);
        }
      },
      // Name placeholders (for custom templates)
      "npm-username": {
        check: () => packageJson.name.includes("npm-username"),
        replace: () => {
          packageJson.name = packageJson.name.replace("npm-username", npmUsername);
          console.info(`Set package org: @${npmUsername}`);
        }
      },
      "plugin-name": {
        check: () => packageJson.name.includes("plugin-name"),
        replace: () => {
          packageJson.name = packageJson.name.replace("plugin-name", pluginDirName);
          console.info(`Set package name: ${packageJson.name}`);
        }
      },
      // Description placeholder
      "${PLUGINDESCRIPTION}": {
        check: () => packageJson.description === "${PLUGINDESCRIPTION}",
        replace: () => {
          const simpleName = pluginDirName.replace("plugin-", "");
          packageJson.description = `ElizaOS plugin for ${simpleName}`;
          console.info(`Set description: ${packageJson.description}`);
        }
      },
      // Repository URL placeholder (only for GitHub publishing)
      "${REPO_URL}": {
        check: () => !!(!opts.npm && credentials && packageJson.repository && (packageJson.repository.url === "${REPO_URL}" || packageJson.repository.url === "")),
        replace: () => {
          if (!packageJson.repository) {
            packageJson.repository = { type: "git", url: "" };
          }
          if (credentials) {
            packageJson.repository.url = `git+https://github.com/${credentials.username}/${pluginDirName}.git`;
            console.info(`Set repository: ${packageJson.repository.url}`);
          }
        }
      },
      // Author placeholder (only for GitHub publishing)
      "${GITHUB_USERNAME}": {
        check: () => !!(!opts.npm && credentials && packageJson.author === "${GITHUB_USERNAME}"),
        replace: () => {
          if (credentials) {
            packageJson.author = credentials.username;
            console.info(`Set author: ${packageJson.author}`);
          }
        }
      },
      // Bugs URL placeholder (only for GitHub publishing)
      "bugs-placeholder": {
        check: () => !!(!opts.npm && credentials && packageJson.bugs && packageJson.bugs.url && packageJson.bugs.url.includes("${GITHUB_USERNAME}")),
        replace: () => {
          if (packageJson.bugs?.url && credentials) {
            packageJson.bugs.url = packageJson.bugs.url.replace("${GITHUB_USERNAME}", credentials.username).replace("${PLUGINNAME}", pluginDirName);
            console.info(`Set bugs URL: ${packageJson.bugs.url}`);
          }
        }
      }
    };
    Object.entries(placeholderReplacements).forEach(([_, replacement]) => {
      if (replacement.check()) {
        replacement.replace();
      }
    });
    const finalPluginName = packageJson.name.startsWith("@") ? packageJson.name.split("/")[1] : packageJson.name;
    await fs8.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), "utf-8");
    await validatePluginRequirements(cwd, packageJson);
    const settings = await getRegistrySettings();
    const publishUsername = credentials ? credentials.username : npmUsername;
    settings.publishConfig = {
      registry: settings.defaultRegistry,
      username: publishUsername,
      useNpm: opts.npm,
      platform: packageJson.platform
    };
    await saveRegistrySettings(settings);
    const packageMetadata = await generatePackageMetadata(
      packageJson,
      cliVersion,
      publishUsername
    );
    console.debug("Generated package metadata:", packageMetadata);
    const userIsMaintainer = isMaintainer(packageJson, publishUsername);
    console.info(
      `User ${publishUsername} is ${userIsMaintainer ? "a maintainer" : "not a maintainer"} of this package`
    );
    if (opts.dryRun) {
      console.info(`Running dry run for plugin registry publication...`);
      const success = await savePackageToRegistry(packageMetadata, true);
      if (success) {
        console.log(
          `[\u221A] Dry run successful: Registry metadata generated for ${packageJson.name}@${packageJson.version}`
        );
        console.info(`Files created in ${LOCAL_REGISTRY_PATH2}`);
      } else {
        console.error("Dry run failed");
        process.exit(1);
      }
      return;
    }
    if (opts.test) {
      console.info(`Running plugin publish tests...`);
      if (opts.npm) {
        console.info("\nTesting npm publishing:");
        const npmTestSuccess = await testPublishToNpm(cwd);
        if (!npmTestSuccess) {
          console.error("npm publishing test failed");
          process.exit(1);
        }
      }
      console.info("\nTesting GitHub publishing:");
      const githubTestSuccess = await testPublishToGitHub(
        packageJson,
        credentials?.username || ""
      );
      if (!githubTestSuccess) {
        console.error("GitHub publishing test failed");
        process.exit(1);
      }
      if (!opts.skipRegistry) {
        console.info("\nTesting registry publishing:");
        const registryTestSuccess = await savePackageToRegistry(packageMetadata, true);
        if (!registryTestSuccess) {
          console.error("Registry publishing test failed");
          process.exit(1);
        }
      } else {
        console.info(
          "\nSkipping registry publishing test as requested with --skip-registry flag"
        );
      }
      console.log("All tests passed successfully!");
      return;
    }
    let publishResult = false;
    let publishedToGitHub = false;
    let registryPrUrl = null;
    console.info(`Publishing plugin to npm...`);
    await publishToNpm(cwd, packageJson, npmUsername);
    packageMetadata.npmPackage = packageJson.name;
    if (!opts.npm && credentials) {
      try {
        publishResult = await publishToGitHubAction(
          cwd,
          packageJson,
          credentials,
          opts.skipRegistry,
          false
        );
        if (!publishResult) {
          process.exit(1);
        }
        publishedToGitHub = true;
        packageMetadata.githubRepo = `${credentials.username}/${finalPluginName}`;
        if (typeof publishResult === "object" && publishResult.prUrl && !opts.skipRegistry) {
          registryPrUrl = publishResult.prUrl;
          console.log(`[\u221A] Registry pull request created: ${registryPrUrl}`);
        }
      } catch (error) {
        console.error("GitHub publishing failed:", error);
        process.exit(1);
      }
    }
    displayRegistryPublicationMessage(opts, userIsMaintainer, registryPrUrl || void 0);
    console.log(`Successfully published plugin ${packageJson.name}@${packageJson.version}`);
    console.log("\nYour plugin is now available at:");
    console.log(`NPM: https://www.npmjs.com/package/${packageJson.name}`);
    if (publishedToGitHub && credentials) {
      console.log(`GitHub: https://github.com/${credentials.username}/${finalPluginName}`);
    }
    console.log("\n[\u{1F4DD}] Important: For future updates to your plugin:");
    console.log("   Use standard npm and git workflows, not the ElizaOS CLI:");
    console.log("   1. Make your changes and test locally");
    console.log("   2. Update version: npm version patch|minor|major");
    console.log("   3. Publish to npm: npm publish");
    if (publishedToGitHub) {
      console.log("   4. Push to GitHub: git push origin main && git push --tags");
    }
    console.log("\n   The ElizaOS registry will automatically sync with npm updates.");
    console.log('   Only use "elizaos publish" for initial publishing of new plugins.');
  } catch (error) {
    handleError(error);
  }
});

// src/commands/monorepo/index.ts
import { Command as Command6 } from "commander";

// src/commands/monorepo/actions/clone.ts
import { existsSync as existsSync12, readdirSync as readdirSync3, mkdirSync } from "fs";
import path20 from "path";
async function cloneRepository(repo, branch, destination) {
  try {
    const repoUrl = `https://github.com/${repo}`;
    await bunExecInherit("git", ["clone", "-b", branch, repoUrl, destination]);
  } catch (error) {
    if (error instanceof Error && error.message.includes("exit code 128")) {
      console.error(`
[X] Branch '${branch}' doesn't exist in the ElizaOS repository.`);
      console.error(`Please specify a valid branch name. Common branches include:`);
      console.error(`  \u2022 main - The main branch`);
      console.error(`  \u2022 develop - The development branch (default)`);
      console.error(
        `
For a complete list of branches, visit: https://github.com/elizaOS/eliza/branches`
      );
      throw new Error(`Branch '${branch}' not found`);
    }
    throw new Error(
      `Failed to clone repository: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
function prepareDestination(dir) {
  const destinationDir = path20.resolve(process.cwd(), dir);
  if (existsSync12(destinationDir)) {
    const files = readdirSync3(destinationDir);
    if (files.length > 0) {
      throw new Error(`Destination directory ${destinationDir} already exists and is not empty`);
    }
  } else {
    mkdirSync(destinationDir, { recursive: true });
  }
  return destinationDir;
}
async function cloneMonorepo(cloneInfo) {
  const { repo, branch, destination } = cloneInfo;
  const destinationDir = prepareDestination(destination);
  await cloneRepository(repo, branch, destinationDir);
  return;
}

// src/commands/monorepo/utils/setup-instructions.ts
import path21 from "path";
function getBunInstallInstructions() {
  const platform = process.platform;
  if (platform === "win32") {
    return {
      platform: "Windows",
      commands: ['powershell -c "irm bun.sh/install.ps1 | iex"'],
      alternatives: ["scoop install bun (if you have Scoop)"]
    };
  } else {
    const commands = ["curl -fsSL https://bun.sh/install | bash"];
    const alternatives = [];
    if (platform === "darwin") {
      alternatives.push("brew install bun (if you have Homebrew)");
    }
    return {
      platform: platform === "darwin" ? "macOS" : "Linux",
      commands,
      alternatives: alternatives.length > 0 ? alternatives : void 0
    };
  }
}
function displayBasicSteps(cdPath) {
  console.log("\nTo complete the ElizaOS setup, follow these steps:\n");
  console.log("1. Navigate to the project directory:");
  console.log(`   cd ${cdPath}`);
  console.log("\n2. Install dependencies:");
  console.log("   bun install");
  console.log("\n3. Build the project:");
  console.log("   bun run build");
  console.log("\n4. Start ElizaOS:");
  console.log("   bun run start or bun run dev");
}
function displayPrerequisites() {
  console.log(`
${emoji.list("Prerequisites:")}`);
  console.log(`   ${emoji.bullet("Node.js 23.3.0+")}`);
  console.log(`   ${emoji.bullet("Bun (JavaScript runtime & package manager)")}`);
}
function displayBunInstructions() {
  console.log(`
${emoji.rocket("If you don't have Bun installed:")}`);
  const instructions = getBunInstallInstructions();
  instructions.commands.forEach((command) => {
    console.log(`   ${command}`);
  });
  if (instructions.alternatives) {
    instructions.alternatives.forEach((alt) => {
      console.log(`   Alternative: ${alt}`);
    });
  }
  console.log("   More options: https://bun.sh/docs/installation");
  console.log("   After installation, restart your terminal");
}
function displayNextSteps(targetDir) {
  const cdPath = path21.relative(process.cwd(), targetDir);
  displayBasicSteps(cdPath);
  displayPrerequisites();
  displayBunInstructions();
}

// src/commands/monorepo/index.ts
var monorepo = new Command6().name("monorepo").description("Clone ElizaOS monorepo from a specific branch, defaults to develop").option("-b, --branch <branch>", "Branch to install", "develop").option("-d, --dir <directory>", "Destination directory", "./eliza").action(async (options) => {
  try {
    const repo = "elizaOS/eliza";
    const branch = options.branch || "develop";
    const dir = options.dir || "./eliza";
    const destinationDir = prepareDestination(dir);
    const cloneInfo = {
      repo,
      branch,
      destination: dir
    };
    await cloneMonorepo(cloneInfo);
    displayNextSteps(destinationDir);
  } catch (error) {
    handleError(error);
  }
});

// src/project.ts
import {
  logger as logger15
} from "@elizaos/core";
import { stringToUuid } from "@elizaos/core";
import * as fs9 from "fs";
import path22 from "path";
function isPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return true;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return true;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return true;
    }
  }
  return false;
}
function extractPlugin(module) {
  if (module && typeof module === "object" && typeof module.name === "string" && typeof module.description === "string") {
    return module;
  }
  if (module && typeof module === "object" && module.default && typeof module.default === "object" && typeof module.default.name === "string" && typeof module.default.description === "string") {
    return module.default;
  }
  for (const key in module) {
    if (key !== "default" && module[key] && typeof module[key] === "object" && typeof module[key].name === "string" && typeof module[key].description === "string") {
      return module[key];
    }
  }
  throw new Error("Could not extract plugin from module");
}
async function loadProject(dir) {
  try {
    const dirInfo = detectDirectoryType(dir);
    if (!dirInfo.hasPackageJson) {
      throw new Error(`No package.json found in ${dir}`);
    }
    const packageJson = JSON.parse(fs9.readFileSync(path22.join(dir, "package.json"), "utf8"));
    const main2 = packageJson.main;
    if (!main2) {
      logger15.warn("No main field found in package.json, using default character");
      const defaultCharacterName = "Eliza (Default)";
      const elizaCharacter = getElizaCharacter();
      const defaultAgent = {
        character: {
          ...elizaCharacter,
          id: stringToUuid(defaultCharacterName),
          name: defaultCharacterName
        },
        init: async () => {
          logger15.info("Initializing default Eliza character");
        }
      };
      return {
        agents: [defaultAgent],
        dir
      };
    }
    const entryPoints = [
      path22.join(dir, main2),
      path22.join(dir, "dist/index.js"),
      path22.join(dir, "src/index.ts"),
      path22.join(dir, "src/index.js"),
      path22.join(dir, "index.ts"),
      path22.join(dir, "index.js")
    ];
    let projectModule = null;
    for (const entryPoint of entryPoints) {
      if (fs9.existsSync(entryPoint)) {
        try {
          const importPath = path22.resolve(entryPoint);
          const importUrl = process.platform === "win32" ? "file:///" + importPath.replace(/\\/g, "/") : "file://" + importPath;
          projectModule = await import(importUrl);
          logger15.info(`Loaded project from ${entryPoint}`);
          const exportKeys = Object.keys(projectModule);
          logger15.debug(`Module exports: ${exportKeys.join(", ")}`);
          if (exportKeys.includes("default")) {
            logger15.debug(`Default export type: ${typeof projectModule.default}`);
            if (typeof projectModule.default === "object" && projectModule.default !== null) {
              logger15.debug(`Default export keys: ${Object.keys(projectModule.default).join(", ")}`);
            }
          }
          break;
        } catch (error) {
          logger15.warn(`Failed to import project from ${entryPoint}:`, error);
        }
      }
    }
    if (!projectModule) {
      throw new Error("Could not find project entry point");
    }
    const moduleIsPlugin = isPlugin(projectModule);
    logger15.debug(`Is this a plugin? ${moduleIsPlugin}`);
    if (moduleIsPlugin) {
      logger15.info("Detected plugin module instead of project");
      try {
        const plugin = extractPlugin(projectModule);
        logger15.debug(`Found plugin: ${plugin.name} - ${plugin.description}`);
        logger15.debug(`Plugin has the following properties: ${Object.keys(plugin).join(", ")}`);
        const completePlugin = {
          // Copy all other properties from the original plugin first
          ...plugin,
          // Then override with defaults if needed
          name: plugin.name || "unknown-plugin",
          description: plugin.description || "No description",
          init: plugin.init || (async () => {
            logger15.info(`Dummy init for plugin: ${plugin.name}`);
          })
        };
        const characterName = "Eliza (Test Mode)";
        const elizaCharacter = getElizaCharacter();
        const testCharacter = {
          ...elizaCharacter,
          id: stringToUuid(characterName),
          name: characterName,
          system: `${elizaCharacter.system} Testing the plugin: ${completePlugin.name}.`
        };
        logger15.info(`Using Eliza character as test agent for plugin: ${completePlugin.name}`);
        const testAgent = {
          character: testCharacter,
          plugins: [completePlugin],
          // Only include the plugin being tested
          init: async () => {
            logger15.info(`Initializing Eliza test agent for plugin: ${completePlugin.name}`);
          }
        };
        return {
          agents: [testAgent],
          dir,
          isPlugin: true,
          pluginModule: completePlugin
        };
      } catch (error) {
        logger15.error("Error extracting plugin from module:", error);
        throw error;
      }
    }
    const agents = [];
    if (projectModule.default && typeof projectModule.default === "object" && Array.isArray(projectModule.default.agents)) {
      agents.push(...projectModule.default.agents);
      logger15.debug(`Found ${agents.length} agents in default export's agents array`);
    } else {
      for (const [key, value] of Object.entries(projectModule)) {
        if (key === "default" && value && typeof value === "object") {
          if (value.character && value.init) {
            agents.push(value);
            logger15.debug(`Found agent in default export (single agent)`);
          }
        } else if (value && typeof value === "object" && value.character && value.init) {
          agents.push(value);
          logger15.debug(`Found agent in named export: ${key}`);
        }
      }
    }
    if (agents.length === 0) {
      throw new Error("No agents found in project");
    }
    const project = {
      agents,
      dir
    };
    return project;
  } catch (error) {
    logger15.error("Error loading project:", error);
    throw error;
  }
}

// src/utils/port-validation.ts
function validatePort(value) {
  const port = Number.parseInt(value, 10);
  if (Number.isNaN(port) || port <= 0 || port > 65535) {
    throw new Error("Port must be a number between 1 and 65535");
  }
  return port;
}

// src/commands/start/index.ts
import { logger as logger20 } from "@elizaos/core";
import { Command as Command7 } from "commander";
import * as fs10 from "fs";
import * as path24 from "path";

// src/commands/start/actions/server-start.ts
import { logger as logger19 } from "@elizaos/core";

// src/commands/start/actions/agent-start.ts
import {
  AgentRuntime as AgentRuntime2,
  encryptedCharacter,
  logger as logger18,
  stringToUuid as stringToUuid2
} from "@elizaos/core";
import { plugin as sqlPlugin } from "@elizaos/plugin-sql";

// src/commands/start/utils/config-utils.ts
import dotenv from "dotenv";
async function loadEnvConfig() {
  const envInfo = await UserEnvironment.getInstanceInfo();
  if (envInfo.paths.envFilePath) {
    dotenv.config({ path: envInfo.paths.envFilePath });
  }
  return process.env;
}
function hasCharacterSecrets(character) {
  return character?.settings?.secrets && Object.keys(character.settings.secrets).length > 0;
}
function ensureCharacterSettings(character) {
  if (!character.settings) {
    character.settings = {};
  }
}
async function loadLocalEnvSecrets() {
  const envPath = await getLocalEnvPath();
  if (!envPath) {
    return null;
  }
  return await parseEnvFile(envPath);
}
async function setDefaultSecretsFromEnv(character) {
  ensureCharacterSettings(character);
  if (hasCharacterSecrets(character)) {
    return false;
  }
  const envSecrets = await loadLocalEnvSecrets();
  if (!envSecrets) {
    return false;
  }
  character.settings.secrets = envSecrets;
  return true;
}

// src/commands/start/utils/dependency-resolver.ts
import { logger as logger16 } from "@elizaos/core";
function resolvePluginDependencies(availablePlugins, isTestMode = false) {
  const resolutionOrder = [];
  const visited = /* @__PURE__ */ new Set();
  const visiting = /* @__PURE__ */ new Set();
  function visit(pluginName) {
    if (!availablePlugins.has(pluginName)) {
      logger16.warn(`Plugin dependency "${pluginName}" not found and will be skipped.`);
      return;
    }
    if (visited.has(pluginName)) return;
    if (visiting.has(pluginName)) {
      logger16.error(`Circular dependency detected involving plugin: ${pluginName}`);
      return;
    }
    visiting.add(pluginName);
    const plugin = availablePlugins.get(pluginName);
    if (plugin) {
      const deps = [...plugin.dependencies || []];
      if (isTestMode) {
        deps.push(...plugin.testDependencies || []);
      }
      for (const dep of deps) {
        visit(dep);
      }
    }
    visiting.delete(pluginName);
    visited.add(pluginName);
    resolutionOrder.push(pluginName);
  }
  for (const name of availablePlugins.keys()) {
    if (!visited.has(name)) {
      visit(name);
    }
  }
  const finalPlugins = resolutionOrder.map((name) => availablePlugins.get(name)).filter((p) => p);
  logger16.info(`Final plugins being loaded: ${finalPlugins.map((p) => p.name).join(", ")}`);
  return finalPlugins;
}

// src/commands/start/utils/plugin-utils.ts
import { logger as logger17 } from "@elizaos/core";
function isValidPluginShape(obj) {
  if (!obj || typeof obj !== "object" || !obj.name) {
    return false;
  }
  return !!(obj.init || obj.services || obj.providers || obj.actions || obj.evaluators || obj.description);
}
async function loadAndPreparePlugin(pluginName) {
  const version = getCliInstallTag();
  let pluginModule;
  const context = detectPluginContext(pluginName);
  if (context.isLocalDevelopment) {
    try {
      pluginModule = await loadPluginModule(pluginName);
      if (!pluginModule) {
        logger17.error(`Failed to load local plugin ${pluginName}.`);
        provideLocalPluginGuidance(pluginName, context);
        return null;
      }
    } catch (error) {
      logger17.error(`Error loading local plugin ${pluginName}: ${error}`);
      provideLocalPluginGuidance(pluginName, context);
      return null;
    }
  } else {
    try {
      pluginModule = await loadPluginModule(pluginName);
      if (!pluginModule) {
        logger17.info(`Plugin ${pluginName} not available, installing...`);
        await installPlugin(pluginName, process.cwd(), version);
        pluginModule = await loadPluginModule(pluginName);
      }
    } catch (error) {
      logger17.error(`Failed to process plugin ${pluginName}: ${error}`);
      return null;
    }
  }
  if (!pluginModule) {
    logger17.error(`Failed to load module for plugin ${pluginName}.`);
    return null;
  }
  const expectedFunctionName = `${pluginName.replace(/^@elizaos\/plugin-/, "").replace(/^@elizaos\//, "").replace(/-./g, (match) => match[1].toUpperCase())}Plugin`;
  const exportsToCheck = [
    pluginModule[expectedFunctionName],
    pluginModule.default,
    ...Object.values(pluginModule)
  ];
  for (const potentialPlugin of exportsToCheck) {
    if (isValidPluginShape(potentialPlugin)) {
      return potentialPlugin;
    }
  }
  logger17.warn(`Could not find a valid plugin export in ${pluginName}.`);
  return null;
}

// src/commands/start/actions/agent-start.ts
async function startAgent(character, server, init, plugins2 = [], options = {}) {
  character.id ??= stringToUuid2(character.name);
  if (!hasCharacterSecrets(character)) {
    await setDefaultSecretsFromEnv(character);
  }
  const loadedPlugins = /* @__PURE__ */ new Map();
  loadedPlugins.set(sqlPlugin.name, sqlPlugin);
  const pluginsToLoad = new Set(character.plugins || []);
  for (const p of plugins2) {
    if (typeof p === "string") {
      pluginsToLoad.add(p);
    } else if (isValidPluginShape(p) && !loadedPlugins.has(p.name)) {
      loadedPlugins.set(p.name, p);
      (p.dependencies || []).forEach((dep) => pluginsToLoad.add(dep));
      if (options.isTestMode) {
        (p.testDependencies || []).forEach((dep) => pluginsToLoad.add(dep));
      }
    }
  }
  const allAvailablePlugins = /* @__PURE__ */ new Map();
  for (const p of loadedPlugins.values()) {
    allAvailablePlugins.set(p.name, p);
  }
  for (const name of pluginsToLoad) {
    if (!allAvailablePlugins.has(name)) {
      const loaded = await loadAndPreparePlugin(name);
      if (loaded) {
        allAvailablePlugins.set(loaded.name, loaded);
      }
    }
  }
  const finalPlugins = resolvePluginDependencies(allAvailablePlugins, options.isTestMode);
  const runtime = new AgentRuntime2({
    character: encryptedCharacter(character),
    plugins: finalPlugins,
    settings: await loadEnvConfig()
  });
  const initWrapper = async (runtime2) => {
    if (init) {
      await init(runtime2);
    }
  };
  await initWrapper(runtime);
  await runtime.initialize();
  try {
    const migrationService = runtime.getService("database_migration");
    if (migrationService) {
      logger18.info("Discovering plugin schemas for dynamic migration...");
      migrationService.discoverAndRegisterPluginSchemas(finalPlugins);
      logger18.info("Running all plugin migrations...");
      await migrationService.runAllPluginMigrations();
      logger18.info("All plugin migrations completed successfully");
    } else {
      logger18.warn("DatabaseMigrationService not found - plugin schema migrations skipped");
    }
  } catch (error) {
    logger18.error("Failed to run plugin migrations:", error);
    throw error;
  }
  server.registerAgent(runtime);
  logger18.log(`Started ${runtime.character.name} as ${runtime.agentId}`);
  return runtime;
}
async function stopAgent(runtime, server) {
  await runtime.close();
  server.unregisterAgent(runtime.agentId);
  logger18.success(`Agent ${runtime.character.name} stopped successfully!`);
}

// src/commands/start/actions/server-start.ts
import path23 from "path";
import { fileURLToPath as fileURLToPath4 } from "url";
import { existsSync as existsSync14, readFileSync as readFileSync6 } from "fs";
async function startAgents(options) {
  const postgresUrl = await configureDatabaseSettings(options.configure);
  if (postgresUrl) process.env.POSTGRES_URL = postgresUrl;
  const pgliteDataDir = postgresUrl ? void 0 : await resolvePgliteDir();
  const moduleLoader = getModuleLoader();
  const serverModule = await moduleLoader.load("@elizaos/server");
  const { AgentServer, jsonToCharacter, loadCharacterTryPath } = serverModule;
  const __filename = fileURLToPath4(import.meta.url);
  const __dirname = path23.dirname(__filename);
  let cliDistPath = path23.resolve(__dirname, "../../../");
  const indexPath = path23.join(cliDistPath, "index.html");
  if (!existsSync14(indexPath)) {
    let currentDir = __dirname;
    while (currentDir !== path23.dirname(currentDir)) {
      const packageJsonPath = path23.join(currentDir, "package.json");
      if (existsSync14(packageJsonPath)) {
        try {
          const packageJson = JSON.parse(readFileSync6(packageJsonPath, "utf-8"));
          if (packageJson.name === "@elizaos/cli") {
            const distPath = path23.join(currentDir, "dist");
            if (existsSync14(path23.join(distPath, "index.html"))) {
              cliDistPath = distPath;
              break;
            }
          }
        } catch {
        }
      }
      currentDir = path23.dirname(currentDir);
    }
  }
  const server = new AgentServer();
  await server.initialize({
    dataDir: pgliteDataDir,
    postgresUrl: postgresUrl || void 0
  });
  server.startAgent = (character) => startAgent(character, server);
  server.stopAgent = (runtime) => stopAgent(runtime, server);
  server.loadCharacterTryPath = loadCharacterTryPath;
  server.jsonToCharacter = jsonToCharacter;
  const desiredPort = options.port || Number.parseInt(process.env.SERVER_PORT || "3000");
  const serverPort = await findNextAvailablePort(desiredPort);
  if (serverPort !== desiredPort) {
    logger19.warn(`Port ${desiredPort} is in use, using port ${serverPort} instead`);
  }
  process.env.SERVER_PORT = serverPort.toString();
  try {
    await server.start(serverPort);
  } catch (error) {
    logger19.error(`Failed to start server on port ${serverPort}:`, error);
    throw error;
  }
  if (options.projectAgents && options.projectAgents.length > 0) {
    for (const projectAgent of options.projectAgents) {
      await startAgent(
        projectAgent.character,
        server,
        projectAgent.init,
        projectAgent.plugins || []
      );
    }
  } else if (options.characters && options.characters.length > 0) {
    for (const character of options.characters) {
      await startAgent(character, server);
    }
  } else {
    const elizaCharacter = getElizaCharacter();
    await startAgent(elizaCharacter, server);
  }
}

// src/commands/start/index.ts
var start = new Command7().name("start").description("Build and start the Eliza agent server").option("-c, --configure", "Reconfigure services and AI models").option("-p, --port <port>", "Port to listen on", validatePort).option("--character <paths...>", "Character file(s) to use").hook("preAction", async () => {
  await displayBanner();
}).action(async (options) => {
  try {
    await loadEnvConfig();
    const localModulesPath = path24.join(process.cwd(), "node_modules");
    if (process.env.NODE_PATH) {
      process.env.NODE_PATH = `${localModulesPath}${path24.delimiter}${process.env.NODE_PATH}`;
    } else {
      process.env.NODE_PATH = localModulesPath;
    }
    const localBinPath = path24.join(process.cwd(), "node_modules", ".bin");
    if (process.env.PATH) {
      process.env.PATH = `${localBinPath}${path24.delimiter}${process.env.PATH}`;
    } else {
      process.env.PATH = localBinPath;
    }
    const cwd = process.cwd();
    const dirInfo = detectDirectoryType(cwd);
    const isMonorepo = dirInfo.type === "elizaos-monorepo";
    if (!isMonorepo && !process.env.ELIZA_TEST_MODE) {
      try {
        await buildProject(cwd, false);
      } catch (error) {
        logger20.error(`Build error: ${error instanceof Error ? error.message : String(error)}`);
        logger20.warn(
          "Build failed, but continuing with start. Some features may not work correctly."
        );
      }
    }
    let characters = [];
    let projectAgents = [];
    if (options.character && options.character.length > 0) {
      const moduleLoader = getModuleLoader();
      const serverModule = await moduleLoader.load("@elizaos/server");
      const { loadCharacterTryPath } = serverModule;
      for (const charPath of options.character) {
        const resolvedPath = path24.resolve(charPath);
        if (!fs10.existsSync(resolvedPath)) {
          logger20.error(`Character file not found: ${resolvedPath}`);
          throw new Error(`Character file not found: ${resolvedPath}`);
        }
        try {
          const character = await loadCharacterTryPath(resolvedPath);
          if (character) {
            characters.push(character);
            logger20.info(`Successfully loaded character: ${character.name}`);
          } else {
            logger20.error(
              `Failed to load character from ${resolvedPath}: Invalid or empty character file`
            );
            throw new Error(`Invalid character file: ${resolvedPath}`);
          }
        } catch (e) {
          logger20.error(`Failed to load character from ${resolvedPath}:`, e);
          throw new Error(`Invalid character file: ${resolvedPath}`);
        }
      }
    } else {
      try {
        const cwd2 = process.cwd();
        const dirInfo2 = detectDirectoryType(cwd2);
        if (dirInfo2.hasPackageJson && dirInfo2.type !== "non-elizaos-dir") {
          logger20.info("No character files specified, attempting to load project agents...");
          const project = await loadProject(cwd2);
          if (project.agents && project.agents.length > 0) {
            logger20.info(`Found ${project.agents.length} agent(s) in project configuration`);
            projectAgents = project.agents;
            for (const agent2 of project.agents) {
              if (agent2.character) {
                logger20.info(`Loaded character: ${agent2.character.name}`);
              }
            }
          }
        }
      } catch (e) {
        logger20.debug("Failed to load project agents, will use default character:", e);
      }
    }
    await startAgents({ ...options, characters, projectAgents });
  } catch (e) {
    handleError(e);
    process.exit(1);
  }
});

// src/commands/tee/index.ts
import { Command as Command9 } from "commander";

// src/commands/tee/phala-wrapper.ts
import { Command as Command8 } from "commander";
import { spawn } from "child_process";
import { elizaLogger } from "@elizaos/core";
var phalaCliCommand = new Command8("phala").description("Official Phala Cloud CLI - Manage TEE deployments on Phala Cloud").allowUnknownOption().helpOption(false).action(async (_, command) => {
  const args = command.args;
  try {
    elizaLogger.info("Running Phala CLI command:", ["phala", ...args].join(" "));
    const phalaProcess = spawn("npx", ["--yes", "phala", ...args], {
      stdio: "inherit",
      shell: true
    });
    phalaProcess.on("error", (error) => {
      elizaLogger.error("Failed to execute Phala CLI:", error);
      if (error.message.includes("ENOENT")) {
        elizaLogger.error(
          `
${emoji.error("Error: npx not found. Please install Node.js and npm:")}`
        );
        elizaLogger.error("   Visit https://nodejs.org or use a version manager like nvm");
        elizaLogger.error(
          "   curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash"
        );
      } else {
        elizaLogger.error(`
${emoji.error("Error: Failed to execute Phala CLI")}`);
        elizaLogger.error("   Try running directly: npx phala", args.join(" "));
      }
      process.exit(1);
    });
    phalaProcess.on("exit", (code) => {
      if (code !== 0) {
        elizaLogger.warn(`Phala CLI exited with code: ${code}`);
      }
      process.exit(code || 0);
    });
  } catch (error) {
    elizaLogger.error("Error running Phala CLI:", error);
    elizaLogger.error(`
${emoji.error("Error: Failed to run Phala CLI")}`);
    elizaLogger.error("   Try running Phala CLI directly with: npx phala", args.join(" "));
    elizaLogger.error("   Or visit https://www.npmjs.com/package/phala for more information");
    process.exit(1);
  }
}).configureHelp({
  helpWidth: 100
}).on("--help", () => {
  console.log("");
  console.log("This command wraps the official Phala Cloud CLI.");
  console.log("The Phala CLI will be automatically downloaded if not already installed.");
  console.log("All arguments are passed directly to the Phala CLI.");
  console.log("");
  console.log("Examples:");
  console.log("  $ elizaos tee phala help");
  console.log("  $ elizaos tee phala auth login <api-key>");
  console.log("  $ elizaos tee phala cvms list");
  console.log("  $ elizaos tee phala cvms create --name my-app --compose ./docker-compose.yml");
  console.log("");
  console.log("For full Phala CLI documentation, run:");
  console.log("  $ npx phala help");
});

// src/commands/tee/index.ts
var teeCommand = new Command9("tee").description("Manage TEE deployments").addCommand(phalaCliCommand);

// src/commands/test/index.ts
import { logger as logger27 } from "@elizaos/core";
import { Command as Command10, Option as Option2 } from "commander";

// src/commands/test/actions/run-all-tests.ts
import { logger as logger25 } from "@elizaos/core";

// src/commands/test/utils/project-utils.ts
import { logger as logger21 } from "@elizaos/core";
import * as fs11 from "fs";
import path25 from "path";
function getProjectType(testPath) {
  const targetPath = testPath ? path25.resolve(process.cwd(), testPath) : process.cwd();
  return detectDirectoryType(targetPath);
}
function processFilterName(name) {
  if (!name) return void 0;
  let baseName = name.toLowerCase();
  if (baseName.endsWith(".test.ts") || baseName.endsWith(".test.js") || baseName.endsWith(".spec.ts") || baseName.endsWith(".spec.js")) {
    baseName = baseName.slice(0, -8);
  } else if (baseName.endsWith(".test") || baseName.endsWith(".spec")) {
    baseName = baseName.slice(0, -5);
  }
  return baseName;
}
async function installPluginDependencies(projectInfo) {
  if (projectInfo.type !== "elizaos-plugin") {
    return;
  }
  const project = await loadProject(process.cwd());
  if (project.isPlugin && project.pluginModule?.dependencies && project.pluginModule.dependencies.length > 0) {
    const pluginsDir = path25.join(process.cwd(), ".eliza", "plugins");
    if (!fs11.existsSync(pluginsDir)) {
      await fs11.promises.mkdir(pluginsDir, { recursive: true });
    }
    const packageJsonPath = path25.join(pluginsDir, "package.json");
    if (!fs11.existsSync(packageJsonPath)) {
      const packageJsonContent = {
        name: "test-plugin-dependencies",
        version: "1.0.0",
        description: "A temporary package for installing test plugin dependencies",
        dependencies: {}
      };
      await fs11.promises.writeFile(packageJsonPath, JSON.stringify(packageJsonContent, null, 2));
    }
    const { installPlugin: installPlugin2 } = await import("./utils-H66532NB.js");
    for (const dependency of project.pluginModule.dependencies) {
      await installPlugin2(dependency, pluginsDir);
      const dependencyPath = path25.join(pluginsDir, "node_modules", dependency);
      if (fs11.existsSync(dependencyPath)) {
        try {
          await runBunCommand(["install"], dependencyPath);
        } catch (error) {
          logger21.warn(
            `[Test Command] Failed to install devDependencies for ${dependency}: ${error}`
          );
        }
      }
    }
  }
}

// src/commands/test/actions/component-tests.ts
import { logger as logger23 } from "@elizaos/core";
import { spawn as spawn2 } from "child_process";
import path27 from "path";

// src/utils/testing/tsc-validator.ts
import { logger as logger22 } from "@elizaos/core";
import path26 from "path";
import { existsSync as existsSync17 } from "fs";
async function runTypeCheck(projectPath, strict = true) {
  const tsconfigPath = path26.join(projectPath, "tsconfig.json");
  if (!existsSync17(tsconfigPath)) {
    return {
      success: false,
      errors: [`No tsconfig.json found at ${tsconfigPath}`],
      warnings: []
    };
  }
  try {
    const args = ["--noEmit"];
    if (strict) {
      args.push("--strict");
    }
    const result = await bunExec("tsc", args, {
      cwd: projectPath
    });
    const { stdout, stderr } = result;
    const hasErrors = stderr.includes("error TS") || stdout.includes("error TS");
    return {
      success: !hasErrors,
      errors: hasErrors ? [stderr || stdout] : [],
      warnings: stderr.includes("warning") ? [stderr] : []
    };
  } catch (error) {
    logger22.error("TypeScript validation failed:", error);
    return {
      success: false,
      errors: [`TypeScript validation error: ${error.message}`],
      warnings: []
    };
  }
}

// src/commands/test/actions/component-tests.ts
async function runComponentTests(testPath, options, projectInfo) {
  const cwd = process.cwd();
  const isPlugin2 = projectInfo.type === "elizaos-plugin";
  if (!options.skipTypeCheck) {
    logger23.info("Running TypeScript validation...");
    const typeCheckResult = await runTypeCheck(cwd, true);
    if (!typeCheckResult.success) {
      logger23.error("TypeScript validation failed:");
      typeCheckResult.errors.forEach((error) => logger23.error(error));
      return { failed: true };
    }
    logger23.success("TypeScript validation passed");
  }
  if (!options.skipBuild) {
    try {
      logger23.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      logger23.success(`Build completed successfully`);
    } catch (buildError) {
      logger23.error(`Build failed: ${buildError}`);
      return { failed: true };
    }
  }
  logger23.info("Running component tests...");
  return new Promise((resolve2) => {
    const args = ["test", "--passWithNoTests"];
    if (options.name) {
      const baseName = processFilterName(options.name);
      if (baseName) {
        logger23.info(`Using test filter: ${baseName}`);
        args.push("-t", baseName);
      }
    }
    const monorepoRoot = UserEnvironment.getInstance().findMonorepoRoot(process.cwd());
    const baseDir = monorepoRoot ?? process.cwd();
    const targetPath = testPath ? path27.resolve(baseDir, testPath) : process.cwd();
    logger23.info(`Executing: bun ${args.join(" ")} in ${targetPath}`);
    const child = spawn2("bun", args, {
      stdio: "inherit",
      shell: false,
      cwd: targetPath,
      env: {
        ...process.env,
        FORCE_COLOR: "1",
        // Force color output
        CI: "false"
        // Ensure we're not in CI mode which might buffer
      }
    });
    child.on("close", (code) => {
      logger23.info("Component tests completed");
      resolve2({ failed: code !== 0 });
    });
    child.on("error", (error) => {
      logger23.error("Error running component tests:", error);
      resolve2({ failed: true });
    });
  });
}

// src/commands/test/actions/e2e-tests.ts
import { logger as logger24 } from "@elizaos/core";
import * as dotenv2 from "dotenv";
import * as fs12 from "fs";
import path28 from "path";
async function runE2eTests(testPath, options, projectInfo) {
  if (!options.skipBuild) {
    try {
      const cwd = process.cwd();
      const isPlugin2 = projectInfo.type === "elizaos-plugin";
      logger24.info(`Building ${isPlugin2 ? "plugin" : "project"}...`);
      await buildProject(cwd, isPlugin2);
      logger24.info(`Build completed successfully`);
    } catch (buildError) {
      logger24.error(`Build error: ${buildError}`);
      logger24.warn(`Attempting to continue with tests despite build error`);
    }
  }
  let server;
  try {
    const runtimes = [];
    const projectAgents = [];
    const moduleLoader = getModuleLoader();
    const serverModule = await moduleLoader.load("@elizaos/server");
    const { AgentServer, jsonToCharacter, loadCharacterTryPath } = serverModule;
    const elizaDir = path28.join(process.cwd(), ".eliza");
    const packageName = path28.basename(process.cwd());
    const timestamp = Date.now();
    const uniqueDbDir = path28.join(process.cwd(), ".elizadb-test", `${packageName}-${timestamp}`);
    const elizaDbDir = uniqueDbDir;
    const envInfo = await UserEnvironment.getInstanceInfo();
    const envFilePath = envInfo.paths.envFilePath;
    console.info("Setting up environment...");
    console.info(`Eliza directory: ${elizaDir}`);
    console.info(`Database directory: ${elizaDbDir}`);
    console.info(`Environment file: ${envFilePath}`);
    console.info(`Package name: ${packageName}, Timestamp: ${timestamp}`);
    if (fs12.existsSync(elizaDbDir)) {
      console.info(`Cleaning up existing database directory: ${elizaDbDir}`);
      try {
        fs12.rmSync(elizaDbDir, { recursive: true, force: true });
        console.info(`Successfully cleaned up existing database directory`);
      } catch (error) {
        console.warn(`Failed to clean up existing database directory: ${error}`);
      }
    }
    console.info(`Creating fresh database directory: ${elizaDbDir}`);
    fs12.mkdirSync(elizaDbDir, { recursive: true });
    console.info(`Created database directory: ${elizaDbDir}`);
    process.env.PGLITE_DATA_DIR = elizaDbDir;
    console.info(`Set PGLITE_DATA_DIR to: ${elizaDbDir}`);
    if (fs12.existsSync(envFilePath)) {
      logger24.info(`Loading environment variables from: ${envFilePath}`);
      dotenv2.config({ path: envFilePath });
      logger24.info("Environment variables loaded");
    } else {
      logger24.warn(`Environment file not found: ${envFilePath}`);
    }
    const postgresUrl = process.env.POSTGRES_URL;
    logger24.info(
      `PostgreSQL URL for e2e tests: ${postgresUrl ? "found" : "not found (will use PGlite)"}`
    );
    logger24.info("Creating server instance...");
    server = new AgentServer();
    logger24.info("Server instance created");
    logger24.info("Initializing server...");
    try {
      await server.initialize({
        dataDir: elizaDbDir,
        postgresUrl
      });
      logger24.info("Server initialized successfully");
    } catch (initError) {
      logger24.error("Server initialization failed:", initError);
      throw initError;
    }
    let project;
    try {
      logger24.info("Attempting to load project or plugin...");
      const monorepoRoot = UserEnvironment.getInstance().findMonorepoRoot(process.cwd());
      const baseDir = monorepoRoot ?? process.cwd();
      const targetPath = testPath ? path28.resolve(baseDir, testPath) : process.cwd();
      project = await loadProject(targetPath);
      if (!project || !project.agents || project.agents.length === 0) {
        throw new Error("No agents found in project configuration");
      }
      logger24.info(`Found ${project.agents.length} agents`);
      logger24.info("Setting up server properties...");
      server.startAgent = async (character) => {
        logger24.info(`Starting agent for character ${character.name}`);
        return startAgent(character, server, void 0, [], { isTestMode: true });
      };
      server.loadCharacterTryPath = loadCharacterTryPath;
      server.jsonToCharacter = jsonToCharacter;
      logger24.info("Server properties set up");
      const desiredPort = options.port || Number.parseInt(process.env.SERVER_PORT || "3000");
      const serverPort = await findNextAvailablePort(desiredPort);
      if (serverPort !== desiredPort) {
        logger24.warn(`Port ${desiredPort} is in use for testing, using port ${serverPort} instead.`);
      }
      logger24.info("Starting server...");
      try {
        await server.start(serverPort);
        logger24.info("Server started successfully on port", serverPort);
      } catch (error) {
        logger24.error("Error starting server:", error);
        if (error instanceof Error) {
          logger24.error("Error details:", error.message);
          logger24.error("Stack trace:", error.stack);
        }
        throw error;
      }
      try {
        logger24.info(
          `Found ${project.agents.length} agents in ${project.isPlugin ? "plugin" : "project"}`
        );
        if (project.isPlugin || project.agents.length === 0) {
          process.env.ELIZA_TESTING_PLUGIN = "true";
          logger24.info("Using default Eliza character as test agent");
          try {
            const pluginUnderTest = project.pluginModule;
            if (!pluginUnderTest) {
              throw new Error("Plugin module could not be loaded for testing.");
            }
            const defaultElizaCharacter = getElizaCharacter();
            const runtime = await startAgent(
              defaultElizaCharacter,
              server,
              void 0,
              // No custom init for default test setup
              [pluginUnderTest],
              // Pass the local plugin module directly
              { isTestMode: true }
            );
            server.registerAgent(runtime);
            runtimes.push(runtime);
            projectAgents.push({
              character: defaultElizaCharacter,
              plugins: runtime.plugins
              // Pass all plugins, not just the one under test
            });
            logger24.info("Default test agent started successfully");
          } catch (pluginError) {
            logger24.error(`Error starting plugin test agent: ${pluginError}`);
            throw pluginError;
          }
        } else {
          for (const agent2 of project.agents) {
            try {
              const originalCharacter = { ...agent2.character };
              logger24.debug(`Starting agent: ${originalCharacter.name}`);
              const runtime = await startAgent(
                originalCharacter,
                server,
                agent2.init,
                agent2.plugins || [],
                { isTestMode: true }
                // Pass isTestMode for project tests as well
              );
              runtimes.push(runtime);
              projectAgents.push(agent2);
              await new Promise((resolve2) => setTimeout(resolve2, 1e3));
            } catch (agentError) {
              logger24.error(`Error starting agent ${agent2.character.name}:`, agentError);
              if (agentError instanceof Error) {
                logger24.error("Error details:", agentError.message);
                logger24.error("Stack trace:", agentError.stack);
              }
              logger24.warn(`Skipping agent ${agent2.character.name} due to startup error`);
            }
          }
        }
        if (runtimes.length === 0) {
          throw new Error("Failed to start any agents from project");
        }
        logger24.debug(`Successfully started ${runtimes.length} agents for testing`);
        let totalFailed = 0;
        let anyTestsFound = false;
        for (let i = 0; i < runtimes.length; i++) {
          const runtime = runtimes[i];
          const projectAgent = projectAgents[i];
          if (project.isPlugin) {
            logger24.debug(`Running tests for plugin: ${project.pluginModule?.name}`);
          } else {
            logger24.debug(`Running tests for agent: ${runtime.character.name}`);
          }
          const testRunner = new TestRunner(runtime, projectAgent);
          const currentDirInfo = projectInfo;
          const processedFilter = processFilterName(options.name);
          const results = await testRunner.runTests({
            filter: processedFilter,
            // Only run plugin tests if we're actually in a plugin directory
            skipPlugins: currentDirInfo.type !== "elizaos-plugin",
            // Only run project tests if we're actually in a project directory
            skipProjectTests: currentDirInfo.type !== "elizaos-project",
            skipE2eTests: false
            // Always allow E2E tests
          });
          totalFailed += results.failed;
          if (results.hasTests) {
            anyTestsFound = true;
          }
        }
        return { failed: anyTestsFound ? totalFailed > 0 : false };
      } catch (error) {
        logger24.error("Error in runE2eTests:", error);
        if (error instanceof Error) {
          logger24.error("Error details:", error.message);
          logger24.error("Stack trace:", error.stack);
        } else {
          logger24.error("Unknown error type:", typeof error);
          logger24.error("Error value:", error);
          try {
            logger24.error("Stringified error:", JSON.stringify(error, null, 2));
          } catch (e) {
            logger24.error("Could not stringify error:", e);
          }
        }
        return { failed: true };
      } finally {
        if (process.env.ELIZA_TESTING_PLUGIN) {
          delete process.env.ELIZA_TESTING_PLUGIN;
        }
        try {
          if (fs12.existsSync(elizaDbDir)) {
            console.info(`Cleaning up test database directory: ${elizaDbDir}`);
            fs12.rmSync(elizaDbDir, { recursive: true, force: true });
            console.info(`Successfully cleaned up test database directory`);
          }
          const testDir = path28.dirname(elizaDbDir);
          if (fs12.existsSync(testDir) && fs12.readdirSync(testDir).length === 0) {
            fs12.rmSync(testDir, { recursive: true, force: true });
          }
        } catch (cleanupError) {
          console.warn(`Failed to clean up test database directory: ${cleanupError}`);
        }
      }
    } catch (error) {
      logger24.error("Error in runE2eTests:", error);
      if (error instanceof Error) {
        logger24.error("Error details:", error.message);
        logger24.error("Stack trace:", error.stack);
      } else {
        logger24.error("Unknown error type:", typeof error);
        logger24.error("Error value:", error);
        try {
          logger24.error("Stringified error:", JSON.stringify(error, null, 2));
        } catch (e) {
          logger24.error("Could not stringify error:", e);
        }
      }
      return { failed: true };
    }
  } catch (error) {
    logger24.error("Error in runE2eTests:", error);
    if (error instanceof Error) {
      logger24.error("Error details:", error.message);
      logger24.error("Stack trace:", error.stack);
    } else {
      logger24.error("Unknown error type:", typeof error);
      logger24.error("Error value:", error);
      try {
        logger24.error("Stringified error:", JSON.stringify(error, null, 2));
      } catch (e) {
        logger24.error("Could not stringify error:", e);
      }
    }
    return { failed: true };
  }
}

// src/commands/test/actions/run-all-tests.ts
async function runAllTests(testPath, options) {
  const projectInfo = getProjectType(testPath);
  if (!options.skipBuild) {
    const componentResult = await runComponentTests(testPath, options, projectInfo);
    if (componentResult.failed) {
      logger25.error("Component tests failed. Continuing to e2e tests...");
    }
  }
  const e2eResult = await runE2eTests(testPath, options, projectInfo);
  if (e2eResult.failed) {
    logger25.error("E2E tests failed.");
    process.exit(1);
  }
  logger25.success("All tests passed successfully!");
  process.exit(0);
}

// src/commands/test/utils/port-utils.ts
import * as net from "net";

// src/commands/test/utils/plugin-utils.ts
import { logger as logger26 } from "@elizaos/core";
import * as fs13 from "fs";
import path29 from "path";

// src/commands/test/index.ts
var test = new Command10().name("test").description("Run tests for the current project or a specified plugin").argument("[path]", "Optional path to the project or plugin to test").addOption(
  new Option2("-t, --type <type>", "the type of test to run").choices(["component", "e2e", "all"]).default("all")
).option("--port <port>", "The port to run e2e tests on", validatePort).option("--name <name>", "Filter tests by name").option("--skip-build", "Skip building before running tests").option("--skip-type-check", "Skip TypeScript validation before running tests").hook("preAction", async (thisCommand) => {
  const testPath = thisCommand.args[0];
  const projectInfo = getProjectType(testPath);
  await installPluginDependencies(projectInfo);
}).action(async (testPath, options) => {
  logger27.info("Starting tests...");
  try {
    const projectInfo = getProjectType(testPath);
    switch (options.type) {
      case "component":
        logger27.info("Running component tests only...");
        const componentResult = await runComponentTests(testPath, options, projectInfo);
        if (componentResult.failed) {
          logger27.error("Component tests failed.");
          process.exit(1);
        }
        logger27.success("Component tests passed successfully!");
        break;
      case "e2e":
        logger27.info("Running e2e tests only...");
        const e2eResult = await runE2eTests(testPath, options, projectInfo);
        if (e2eResult.failed) {
          logger27.error("E2E tests failed.");
          process.exit(1);
        }
        logger27.success("E2E tests passed successfully!");
        break;
      case "all":
      default:
        logger27.info("Running all tests...");
        await runAllTests(testPath, options);
        break;
    }
    process.exit(0);
  } catch (error) {
    handleError(error);
  }
});

// src/index.ts
import { logger as logger28 } from "@elizaos/core";
import { Command as Command11 } from "commander";
process.env.NODE_OPTIONS = "--no-deprecation";
process.env.NODE_NO_WARNINGS = "1";
process.env.QUIET_MODE = process.env.QUIET_MODE || "true";
var shutdownState = {
  isShuttingDown: false,
  /**
   * Atomically check and set the shutdown flag
   * @returns true if shutdown was initiated, false if already in progress
   */
  tryInitiateShutdown() {
    if (this.isShuttingDown) {
      return false;
    }
    this.isShuttingDown = true;
    return true;
  }
};
async function gracefulShutdown(signal) {
  if (!shutdownState.tryInitiateShutdown()) {
    logger28.debug(`Ignoring ${signal} - shutdown already in progress`);
    return;
  }
  logger28.info(`Received ${signal}, shutting down gracefully...`);
  try {
    const serverWasStopped = await stopServer();
    if (serverWasStopped) {
      logger28.info("Server stopped successfully");
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    logger28.error(`Error stopping server: ${errorMessage}`);
    logger28.debug("Full error details:", error);
  }
  const exitCode = signal === "SIGINT" ? 130 : signal === "SIGTERM" ? 143 : 0;
  process.exit(exitCode);
}
process.on("SIGINT", () => gracefulShutdown("SIGINT"));
process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
async function main() {
  const delegated = await tryDelegateToLocalCli();
  if (delegated) {
    return;
  }
  if (process.argv.includes("--no-emoji")) {
    configureEmojis({ forceDisable: true });
  }
  if (process.argv.includes("--no-auto-install")) {
    process.env.ELIZA_NO_AUTO_INSTALL = "true";
  }
  const version = getVersion();
  const args = process.argv.slice(2);
  const isUpdateCommand = args.includes("update");
  const willShowBanner = args.length === 0;
  if (!willShowBanner && !isUpdateCommand) {
    const currentVersion = getVersion();
    await checkAndShowUpdateNotification(currentVersion);
  }
  const program = new Command11().name("elizaos").version(version, "-v, --version", "output the version number").option("--no-emoji", "Disable emoji output").option("--no-auto-install", "Disable automatic Bun installation");
  program.addCommand(create).addCommand(monorepo).addCommand(plugins).addCommand(agent).addCommand(teeCommand).addCommand(start).addCommand(update).addCommand(test).addCommand(env).addCommand(dev).addCommand(publish);
  if (process.argv.length === 2) {
    await displayBanner(false);
  }
  await program.parseAsync();
}
main().catch((error) => {
  logger28.error("An error occurred:", error);
  process.exit(1);
});
