// src/utils/bun-exec.ts
import { logger } from "@elizaos/core";
var COMMAND_EXISTS_TIMEOUT_MS = 5e3;
function ensureBunInPath(env = {}) {
  const enhancedEnv = { ...process.env, ...env };
  if (enhancedEnv.PATH) {
    const pathSeparator = process.platform === "win32" ? ";" : ":";
    const currentPaths = enhancedEnv.PATH.split(pathSeparator);
    const bunPaths = [
      process.env.HOME ? `${process.env.HOME}/.bun/bin` : null,
      "/opt/homebrew/bin",
      "/usr/local/bin"
    ].filter(Boolean);
    for (const bunPath of bunPaths) {
      if (bunPath && !currentPaths.some((p) => p === bunPath || p.endsWith("/.bun/bin"))) {
        enhancedEnv.PATH = `${bunPath}${pathSeparator}${enhancedEnv.PATH}`;
      }
    }
  }
  return enhancedEnv;
}
var ProcessExecutionError = class extends Error {
  constructor(message, exitCode, stderr, command) {
    super(message);
    this.exitCode = exitCode;
    this.stderr = stderr;
    this.command = command;
    this.name = "ProcessExecutionError";
  }
};
var ProcessTimeoutError = class extends Error {
  constructor(message, command, timeout) {
    super(message);
    this.command = command;
    this.timeout = timeout;
    this.name = "ProcessTimeoutError";
  }
};
function escapeShellArg(arg) {
  if (arg === "") {
    return '""';
  }
  const escaped = JSON.stringify(arg);
  return escaped;
}
async function readStreamSafe(stream, streamName) {
  if (!stream || typeof stream === "number") {
    return "";
  }
  try {
    const text = await new Response(stream).text();
    return text;
  } catch (error) {
    logger.debug(`[bunExec] Error reading ${streamName}:`, error);
    return "";
  }
}
async function bunExec(command, args = [], options = {}) {
  let proc = null;
  let timeoutId = null;
  try {
    const escapedArgs = args.map(escapeShellArg);
    const fullCommand = [command, ...escapedArgs].join(" ");
    logger.debug(`[bunExec] Executing: ${fullCommand}`);
    const enhancedEnv = ensureBunInPath(options.env);
    proc = Bun.spawn([command, ...args], {
      cwd: options.cwd,
      env: enhancedEnv,
      stdout: options.stdout || options.stdio || "pipe",
      stderr: options.stderr || options.stdio || "pipe"
    });
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        if (proc && proc.exitCode === null) {
          proc.kill();
        }
      });
    }
    const timeoutPromise = new Promise((_, reject) => {
      if (options.timeout && options.timeout > 0) {
        const timeoutMs = options.timeout;
        timeoutId = setTimeout(() => {
          if (proc && proc.exitCode === null) {
            proc.kill();
          }
          reject(
            new ProcessTimeoutError(
              `Command timed out after ${timeoutMs}ms`,
              fullCommand,
              timeoutMs
            )
          );
        }, timeoutMs);
      }
    });
    const [stdout, stderr, exitCode] = await Promise.race([
      // Normal execution path - all operations run concurrently
      Promise.all([
        readStreamSafe(proc.stdout, "stdout"),
        readStreamSafe(proc.stderr, "stderr"),
        proc.exited
      ]),
      // Timeout path
      timeoutPromise
    ]);
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    const success = exitCode === 0;
    if (!success && options.stdio !== "ignore") {
      logger.debug(`[bunExec] Command failed with exit code ${exitCode}`);
      if (stderr) {
        logger.debug(`[bunExec] stderr: ${stderr}`);
      }
    }
    return {
      stdout: stdout.trim(),
      stderr: stderr.trim(),
      exitCode,
      success
    };
  } catch (error) {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (error instanceof ProcessTimeoutError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new ProcessExecutionError(
        `Command execution failed: ${error.message}`,
        null,
        "",
        command
      );
    }
    throw error;
  } finally {
    if (proc && proc.exitCode === null) {
      try {
        proc.kill();
        logger.debug("[bunExec] Killed still-running process in cleanup");
      } catch (cleanupError) {
        logger.debug(
          "[bunExec] Process cleanup error (process may have already exited):",
          cleanupError
        );
      }
    }
  }
}
async function bunExecSimple(command, args = [], options = {}) {
  const result = await bunExec(command, args, options);
  if (!result.success && options.stdio !== "ignore") {
    throw new ProcessExecutionError(
      `Command failed: ${command} ${args.map(escapeShellArg).join(" ")}`,
      result.exitCode,
      result.stderr,
      command
    );
  }
  return { stdout: result.stdout };
}
async function bunExecInherit(command, args = [], options = {}) {
  return bunExec(command, args, {
    ...options,
    stdio: "inherit"
  });
}
async function commandExists(command) {
  try {
    if (process.platform === "win32") {
      const result = await bunExec("where", [command], {
        stdio: "ignore",
        timeout: COMMAND_EXISTS_TIMEOUT_MS
      });
      return result.success;
    } else {
      const result = await bunExec("which", [command], {
        stdio: "ignore",
        timeout: COMMAND_EXISTS_TIMEOUT_MS
      });
      return result.success;
    }
  } catch {
    return false;
  }
}

export {
  ProcessExecutionError,
  ProcessTimeoutError,
  bunExec,
  bunExecSimple,
  bunExecInherit,
  commandExists
};
